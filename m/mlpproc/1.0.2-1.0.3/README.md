# Comparing `tmp/mlpproc-1.0.2-py3-none-any.whl.zip` & `tmp/mlpproc-1.0.3-py3-none-any.whl.zip`

## zipinfo {}

```diff
@@ -1,22 +1,21 @@
-Zip file size: 42811 bytes, number of entries: 20
--rw-rw-r--  2.0 unx     1054 b- defN 22-Mar-11 13:35 mlpproc/__init__.py
--rw-rw-r--  2.0 unx     5263 b- defN 21-Feb-21 17:27 mlpproc/__main__.py
--rw-rw-r--  2.0 unx    18205 b- defN 21-Dec-09 10:19 mlpproc/blocks.py
--rw-rw-r--  2.0 unx    21177 b- defN 22-Mar-10 23:09 mlpproc/commands.py
--rw-rw-r--  2.0 unx     4425 b- defN 21-Jan-19 12:14 mlpproc/conditions.py
--rw-rw-r--  2.0 unx     5867 b- defN 21-Feb-16 18:31 mlpproc/context.py
--rw-rw-r--  2.0 unx     2051 b- defN 21-Dec-09 09:41 mlpproc/defaults.py
--rw-rw-r--  2.0 unx     6755 b- defN 22-Jun-24 20:02 mlpproc/defs.py
--rw-rw-r--  2.0 unx     5124 b- defN 21-Jan-20 13:05 mlpproc/errors.py
--rw-rw-r--  2.0 unx    11246 b- defN 22-Mar-10 23:07 mlpproc/final_actions.py
--rw-rw-r--  2.0 unx     3744 b- defN 21-Jan-31 11:38 mlpproc/labels.py
--rw-rw-r--  2.0 unx    18945 b- defN 21-Dec-09 12:20 mlpproc/preprocessor.py
--rw-rw-r--  2.0 unx     1614 b- defN 21-Dec-14 16:40 mlpproc/types.py
--rw-rw-r--  2.0 unx     1070 b- defN 20-Dec-30 19:30 mlpproc-1.0.2.data/data/LICENSE
--rwxrwxr-x  2.0 unx       78 b- defN 22-Jun-24 20:03 mlpproc-1.0.2.data/scripts/mlpp
--rw-rw-r--  2.0 unx     1070 b- defN 22-Jun-24 20:03 mlpproc-1.0.2.dist-info/LICENSE
--rw-rw-r--  2.0 unx    23508 b- defN 22-Jun-24 20:03 mlpproc-1.0.2.dist-info/METADATA
--rw-rw-r--  2.0 unx       92 b- defN 22-Jun-24 20:03 mlpproc-1.0.2.dist-info/WHEEL
--rw-rw-r--  2.0 unx        8 b- defN 22-Jun-24 20:03 mlpproc-1.0.2.dist-info/top_level.txt
-?rw-rw-r--  2.0 unx     1549 b- defN 22-Jun-24 20:03 mlpproc-1.0.2.dist-info/RECORD
-20 files, 132845 bytes uncompressed, 40339 bytes compressed:  69.6%
+Zip file size: 44289 bytes, number of entries: 19
+-rw-rw-r--  2.0 unx     1244 b- defN 23-Apr-20 19:18 mlpproc/__init__.py
+-rw-rw-r--  2.0 unx     6116 b- defN 24-May-26 11:40 mlpproc/__main__.py
+-rw-rw-r--  2.0 unx    22874 b- defN 23-Apr-21 09:33 mlpproc/blocks.py
+-rw-rw-r--  2.0 unx    29959 b- defN 23-Apr-21 09:33 mlpproc/commands.py
+-rw-rw-r--  2.0 unx     5576 b- defN 23-Apr-20 19:16 mlpproc/conditions.py
+-rw-rw-r--  2.0 unx     6740 b- defN 23-Apr-20 19:45 mlpproc/context.py
+-rw-rw-r--  2.0 unx     2807 b- defN 23-Apr-21 09:06 mlpproc/defaults.py
+-rw-rw-r--  2.0 unx     7372 b- defN 24-May-26 11:40 mlpproc/defs.py
+-rw-rw-r--  2.0 unx     5849 b- defN 23-Apr-20 19:16 mlpproc/errors.py
+-rw-rw-r--  2.0 unx    13427 b- defN 23-Apr-21 09:02 mlpproc/final_actions.py
+-rw-rw-r--  2.0 unx     4369 b- defN 23-Apr-20 19:16 mlpproc/labels.py
+-rw-rw-r--  2.0 unx    24610 b- defN 23-Apr-21 09:36 mlpproc/preprocessor.py
+-rw-rw-r--  2.0 unx     1070 b- defN 23-Apr-12 06:52 mlpproc-1.0.3.data/data/LICENSE
+-rwxrwxr-x  2.0 unx       78 b- defN 24-May-26 11:43 mlpproc-1.0.3.data/scripts/mlpp
+-rw-rw-r--  2.0 unx     1070 b- defN 24-May-26 11:43 mlpproc-1.0.3.dist-info/LICENSE
+-rw-rw-r--  2.0 unx    23767 b- defN 24-May-26 11:43 mlpproc-1.0.3.dist-info/METADATA
+-rw-rw-r--  2.0 unx       92 b- defN 24-May-26 11:43 mlpproc-1.0.3.dist-info/WHEEL
+-rw-rw-r--  2.0 unx        8 b- defN 24-May-26 11:43 mlpproc-1.0.3.dist-info/top_level.txt
+-rw-rw-r--  2.0 unx     1476 b- defN 24-May-26 11:43 mlpproc-1.0.3.dist-info/RECORD
+19 files, 158504 bytes uncompressed, 41925 bytes compressed:  73.5%
```

## zipnote {}

```diff
@@ -30,32 +30,29 @@
 
 Filename: mlpproc/labels.py
 Comment: 
 
 Filename: mlpproc/preprocessor.py
 Comment: 
 
-Filename: mlpproc/types.py
+Filename: mlpproc-1.0.3.data/data/LICENSE
 Comment: 
 
-Filename: mlpproc-1.0.2.data/data/LICENSE
+Filename: mlpproc-1.0.3.data/scripts/mlpp
 Comment: 
 
-Filename: mlpproc-1.0.2.data/scripts/mlpp
+Filename: mlpproc-1.0.3.dist-info/LICENSE
 Comment: 
 
-Filename: mlpproc-1.0.2.dist-info/LICENSE
+Filename: mlpproc-1.0.3.dist-info/METADATA
 Comment: 
 
-Filename: mlpproc-1.0.2.dist-info/METADATA
+Filename: mlpproc-1.0.3.dist-info/WHEEL
 Comment: 
 
-Filename: mlpproc-1.0.2.dist-info/WHEEL
+Filename: mlpproc-1.0.3.dist-info/top_level.txt
 Comment: 
 
-Filename: mlpproc-1.0.2.dist-info/top_level.txt
-Comment: 
-
-Filename: mlpproc-1.0.2.dist-info/RECORD
+Filename: mlpproc-1.0.3.dist-info/RECORD
 Comment: 
 
 Zip file comment:
```

## mlpproc/__init__.py

```diff
@@ -9,16 +9,29 @@
 - the FileDescriptor class used to initialize contexts
   (used to traceback errors to input files)
 """
 
 from .context import FileDescriptor
 from .defaults import Preprocessor
 from .defs import PREPROCESSOR_NAME, PREPROCESSOR_VERSION
-from .errors import (ErrorMode, PreprocessorError, PreprocessorWarning,
-                     WarningMode)
+from .errors import ErrorMode, PreprocessorError, PreprocessorWarning, WarningMode
 
 __author__ = "Dorian Lesbre"
 __email__ = "dorian.lesbre" + chr(64) + "gmail.com"
 __version__ = PREPROCESSOR_VERSION
-__description__ = "MLPP: Markup Language Pre-Processor for text files (code/html/tex/...) inspired by the C preprocessor"
+__description__ = (
+    "MLPP: Markup Language Pre-Processor for text files (code/html/tex/...)"
+    " inspired by the C preprocessor"
+)
 __license__ = "MIT"
 __url__ = "https://github.com/dlesbre/mlpproc"
+
+__all__ = (
+    "FileDescriptor",
+    "Preprocessor",
+    "PREPROCESSOR_NAME",
+    "PREPROCESSOR_VERSION",
+    "ErrorMode",
+    "PreprocessorError",
+    "PreprocessorWarning",
+    "WarningMode",
+)
```

## mlpproc/__main__.py

```diff
@@ -5,156 +5,180 @@
 
 import argparse
 from os.path import abspath, dirname
 from pathlib import Path
 from sys import stderr, stdin, stdout
 from typing import List, Optional
 
-from .defaults import Preprocessor, define_macro
+from .defaults import Cmd_Def, Preprocessor
 from .defs import PREPROCESSOR_NAME, PREPROCESSOR_VERSION
 from .errors import ErrorMode, WarningMode
+from .preprocessor import Command
 
 parser = argparse.ArgumentParser(prog=PREPROCESSOR_NAME, add_help=False)
 parser.add_argument("--begin", "-b", nargs="?", default=None)
 parser.add_argument("--end", "-e", nargs="?", default=None)
-parser.add_argument("--warnings", "-w", nargs="?", default=None, choices=("hide", "error"))
+parser.add_argument(
+    "--warnings", "-w", nargs="?", default=None, choices=("hide", "error")
+)
 parser.add_argument("--version", "-v", action="store_true")
 parser.add_argument("--output", "-o", nargs="?", type=Path, default=stdout)
 parser.add_argument("--help", "-h", nargs="?", const="", default=None)
 parser.add_argument("--define", "-d", "-D", nargs="?", action="append", default=[])
 parser.add_argument(
-	"--include", "-i", "-I", nargs=1, action="append", default=[], type=abspath# type: ignore
+    "--include", "-i", "-I", nargs=1, action="append", default=[], type=abspath
 )
 parser.add_argument("--silent", "-s", nargs=1, default=[], action="append")
 parser.add_argument("--recursion-depth", "-r", nargs=1, type=int)
 parser.add_argument("input", nargs="?", type=Path, default=stdin)
 
 
-
 def process_defines(preproc: Preprocessor, defines: List[str]) -> None:
-	"""process command line defines
-	defines should be a list of strings like "<ident>" or "<ident>=<value>"
-	"""
-	for define in defines:
-		if isinstance(define, list):
-			define = define[0] # argparse creates nested list for some reason
-		i = define.find("=")
-		if i == -1:
-			name = define
-			value = ""
-		else:
-			name = define[:i]
-			value = define[i+1:]
-		if not name.isidentifier():
-			parser.error("argument --define/-d/-D: invalid define name \"{}\"".format(
-				name
-			))
-			exit(1)
-		define_macro(preproc, name, [], value)
+    """process command line defines
+    defines should be a list of strings like "<ident>" or "<ident>=<value>"
+    """
+    for define in defines:
+        if isinstance(define, list):
+            define = define[0]  # argparse creates nested list for some reason
+        i = define.find("=")
+        if i == -1:
+            name = define
+            value = ""
+        else:
+            name = define[:i]
+            value = define[i + 1 :]
+        if not name.isidentifier():
+            parser.error(
+                'argument --define/-d/-D: invalid define name "{}"'.format(name)
+            )
+            exit(1)
+        Cmd_Def().define_macro(preproc, name, [], value)
+
 
 def process_options(preproc: Preprocessor, arguments: argparse.Namespace) -> None:
-	"""process the preprocessor options
-	see Preprocessor.get_help("") for a list and description of options"""
-	# adding input/output commands
-	input_name = str(arguments.input) if isinstance(arguments.input, Path) else "<stdin>"
-	command = lambda *args: input_name
-	command.doc = "Prints name of input file" # type: ignore
-	preproc.commands["input_name"] = command
-	output_name = str(arguments.output) if isinstance(arguments.output, Path) else "<stdout>"
-	command = lambda *args: output_name
-	command.doc = "Prints name of output file" # type: ignore
-	preproc.commands["output_name"] = command
-
-	# adding defined commands
-	process_defines(preproc, arguments.define)
-
-	# include path
-	preproc.include_path = [
-		abspath(""), # CWD
-		dirname(abspath(input_name)),
-		dirname(abspath(output_name)),
-	] + arguments.include
-
-	# recursion depth
-	if arguments.recursion_depth is not None:
-		rec_depth = arguments.recursion_depth[0]
-		if rec_depth < -1:
-			parser.error("argument --recusion-depth/-r: number must be greater than -1")
-			exit(1)
-		preproc.max_recursion_depth = rec_depth
-
-	# tokens
-	if arguments.begin is not None:
-		preproc.token_begin = arguments.begin
-	if arguments.end is not None:
-		preproc.token_end = arguments.end
-
-	# warning mode
-	if arguments.warnings == "hide":
-		preproc.warning_mode = WarningMode.HIDE
-	elif arguments.warnings == "error":
-		preproc.warning_mode = WarningMode.AS_ERROR
-	else:
-		preproc.warning_mode = WarningMode.PRINT
-
-	# silent warnings
-	preproc.silent_warnings.extend([x[0] for x in arguments.silent])
-
-	# version and help
-	if arguments.version:
-		print("{} version {}".format(PREPROCESSOR_NAME, PREPROCESSOR_VERSION))
-		exit(0)
-	if arguments.help is not None:
-		print(preproc.get_help(arguments.help))
-		exit(0)
+    """process the preprocessor options
+    see Preprocessor.get_help("") for a list and description of options"""
+    # adding input/output commands
+    input_name = (
+        str(arguments.input) if isinstance(arguments.input, Path) else "<stdin>"
+    )
+
+    class Cmd_In(Command):
+        def __call__(self, _p: Preprocessor, _args: str) -> str:
+            return input_name
+
+        doc = "Prints name of input file"
+
+    preproc.commands["input_name"] = Cmd_In()
+    output_name = (
+        str(arguments.output) if isinstance(arguments.output, Path) else "<stdout>"
+    )
+
+    class Cmd_Out(Command):
+        def __call__(self, _p: Preprocessor, _args: str) -> str:
+            return output_name
+
+        doc = "Prints name of output file"
+
+    preproc.commands["output_name"] = Cmd_Out()
+
+    # adding defined commands
+    process_defines(preproc, arguments.define)
+
+    # include path
+    preproc.include_path = [
+        abspath(""),  # CWD
+        dirname(abspath(input_name)),
+        dirname(abspath(output_name)),
+    ] + arguments.include
+
+    # recursion depth
+    if arguments.recursion_depth is not None:
+        rec_depth = arguments.recursion_depth[0]
+        if rec_depth < -1:
+            parser.error("argument --recusion-depth/-r: number must be greater than -1")
+            exit(1)
+        preproc.max_recursion_depth = rec_depth
+
+    # tokens
+    if arguments.begin is not None:
+        preproc.token_begin = arguments.begin
+    if arguments.end is not None:
+        preproc.token_end = arguments.end
+
+    # warning mode
+    if arguments.warnings == "hide":
+        preproc.warning_mode = WarningMode.HIDE
+    elif arguments.warnings == "error":
+        preproc.warning_mode = WarningMode.AS_ERROR
+    else:
+        preproc.warning_mode = WarningMode.PRINT
+
+    # silent warnings
+    preproc.silent_warnings.extend([x[0] for x in arguments.silent])
+
+    # version and help
+    if arguments.version:
+        print("{} version {}".format(PREPROCESSOR_NAME, PREPROCESSOR_VERSION))
+        exit(0)
+    if arguments.help is not None:
+        print(preproc.get_help(arguments.help))
+        exit(0)
+
 
 def preprocessor_main(argv: Optional[List[str]] = None) -> None:
-	"""main function for the preprocessor
-	handles arguments, reads contents from file
-	and write result to output file.
-	argv defaults to sys.argv
-	"""
-	preprocessor = Preprocessor()
-	preprocessor.warning_mode = WarningMode.PRINT
-	preprocessor.error_mode = ErrorMode.PRINT_AND_EXIT
-
-	if argv is None:
-		args = parser.parse_args()
-	else:
-		args = parser.parse_args(argv)
-
-	if stderr.isatty():
-		preprocessor.use_color = True
-
-	process_options(preprocessor, args)
-
-	if isinstance(args.input, Path):
-		try:
-			input_name = str(args.input)
-			with open(args.input, "r") as file:
-				contents = file.read()
-		except FileNotFoundError:
-			parser.error("argument input: file not found \"{}\"".format(args.input))
-		except PermissionError:
-			parser.error("argument input: permission denied \"{}\"".format(args.input))
-	else:
-		# read from stdin
-		input_name = "<stdin>"
-		contents = args.input.read()
-
-	result = preprocessor.process(contents, input_name)
-
-	if isinstance(args.output, Path):
-		try:
-			with open(args.output, "w") as file:
-				file.write(result)
-		except FileNotFoundError:
-			parser.error("argument -o/--output: no such file or directory \"{}\"".format(args.output))
-		except PermissionError:
-			parser.error("argument -o/--output: permission denied \"{}\"".format(args.output))
-	else:
-		# write to stdout
-		args.output.write(result)
+    """main function for the preprocessor
+    handles arguments, reads contents from file
+    and write result to output file.
+    argv defaults to sys.argv
+    """
+    preprocessor = Preprocessor()
+    preprocessor.warning_mode = WarningMode.PRINT
+    preprocessor.error_mode = ErrorMode.PRINT_AND_EXIT
+
+    if argv is None:
+        args = parser.parse_args()
+    else:
+        args = parser.parse_args(argv)
+
+    if stderr.isatty():
+        preprocessor.use_color = True
+
+    process_options(preprocessor, args)
+
+    if isinstance(args.input, Path):
+        try:
+            input_name = str(args.input)
+            with open(args.input, "r") as file:
+                contents = file.read()
+        except FileNotFoundError:
+            parser.error('argument input: file not found "{}"'.format(args.input))
+        except PermissionError:
+            parser.error('argument input: permission denied "{}"'.format(args.input))
+    else:
+        # read from stdin
+        input_name = "<stdin>"
+        contents = args.input.read()
+
+    result = preprocessor.process(contents, input_name)
+
+    if isinstance(args.output, Path):
+        try:
+            with open(args.output, "w") as file:
+                file.write(result)
+        except FileNotFoundError:
+            parser.error(
+                'argument -o/--output: no such file or directory "{}"'.format(
+                    args.output
+                )
+            )
+        except PermissionError:
+            parser.error(
+                'argument -o/--output: permission denied "{}"'.format(args.output)
+            )
+    else:
+        # write to stdout
+        args.output.write(result)
 
 
 if __name__ == "__main__":
-	preprocessor_main()
+    preprocessor_main()
```

## mlpproc/blocks.py

```diff
@@ -1,524 +1,588 @@
 """
 Definitions of default preprocessor blocks
 """
 import argparse
 import re
-from typing import Iterable, Optional, Tuple
+from typing import Any, Iterable, Optional, Tuple
 
 from .conditions import condition_eval, find_matching_close_parenthese
-from .defs import (REGEX_IDENTIFIER, REGEX_IDENTIFIER_END, REGEX_INTEGER,
-                   ArgumentParserNoExit, TokenMatch, to_integer)
-from .preprocessor import Preprocessor
+from .defs import (
+    REGEX_IDENTIFIER,
+    REGEX_IDENTIFIER_END,
+    REGEX_INTEGER,
+    ArgumentParserNoExit,
+    TokenMatch,
+    to_integer,
+)
+from .preprocessor import Block, Command, Preprocessor
 
 # ============================================================
 # simple blocks (comment, void, block, verbatim)
 # ============================================================
 
-def blck_comment(preprocessor: Preprocessor, args: str, _contents: str) -> str:
-	"""The comment block, ignores its contents"""
-	if args.strip() != "":
-		preprocessor.send_warning("extra-arguments", "the void block takes no arguments")
-	return ""
-
-blck_comment.doc = ( # type: ignore
-	"""
-	This block is a comment.
-	All text until the next 'endcomment' is ignored""")
-
-def blck_void(preprocessor: Preprocessor, args: str, contents: str) -> str:
-	"""The void block, processes commands inside it but prints nothing"""
-	if args.strip() != "":
-		preprocessor.send_warning("extra-arguments", "the void block takes no arguments")
-	preprocessor.context.update(preprocessor.current_position.end, "in void block")
-	contents = preprocessor.parse(contents)
-	preprocessor.context.pop()
-	return ""
-
-blck_void.doc = ( # type: ignore
-	"""
-	This block is parsed but not printed.
-	Use it to place comments or a bunch of def
-	without adding whitespace""")
-
-block_parser = ArgumentParserNoExit(prog="block", add_help=False)
-block_parser.add_argument("--begin", "-b", nargs="?", default=None)
-block_parser.add_argument("--end", "-e", nargs="?", default=None)
-block_parser.add_argument("--local-defs", "-d", action="store_true")
-block_parser.add_argument("--local-actions", "-a", action="store_true")
-block_parser.add_argument("--local-clipboard", "-c", action="store_true")
-block_parser.add_argument("--local-labels", "-l", action="store_true")
-
-def blck_block(preprocessor: Preprocessor, args: str, contents: str) -> str:
-	"""The block block. allows restriction of final actions, defs and clipboard to local block"""
-	split = preprocessor.split_args(args)
-	try:
-		arguments = block_parser.parse_args(split)
-	except argparse.ArgumentError:
-		preprocessor.send_error("invalid-argument",
-			"invalid argument.\n"
-			"usage: block [--begin|-b <str>] [--end|-e <str>]\n"
-			"             [--local-actions|-a] [--local-defs|-d] [--local-clipboard|-c]"
-		)
-	begin = preprocessor.token_begin
-	end = preprocessor.token_end
-	if arguments.begin is not None:
-		preprocessor.token_begin = arguments.begin
-	if arguments.end is not None:
-		preprocessor.token_end = arguments.end
-	if arguments.local_defs:
-		commands = preprocessor.commands.copy()
-		blocks = preprocessor.blocks.copy()
-		if "def" in preprocessor.command_vars:
-			defs = preprocessor.command_vars["def"].copy()
-		else:
-			defs = dict()
-	if arguments.local_clipboard:
-		if "clipboard" in preprocessor.command_vars:
-			clipboard = preprocessor.command_vars["clipboard"].copy()
-		else:
-			clipboard = dict()
-	if arguments.local_actions:
-		action = preprocessor.final_actions.copy()
-		preprocessor.final_actions = Preprocessor.final_actions.copy()
-	if arguments.local_labels:
-		labels = preprocessor.labels.copy()
-
-	preprocessor.context.update(preprocessor.current_position.end, "in block block")
-	contents = preprocessor.parse(contents)
-	preprocessor.context.pop()
-
-	if arguments.local_actions:
-		contents = preprocessor.run_final_actions(contents)
-		preprocessor.final_actions = action
-	if arguments.local_labels:
-		preprocessor.labels = labels
-		preprocessor.labels.new_level() # add empty level to pop
-	if arguments.local_defs:
-		preprocessor.commands = commands
-		preprocessor.blocks = blocks
-		preprocessor.command_vars["def"] = defs
-	if arguments.local_clipboard:
-		preprocessor.command_vars["clipboard"] = clipboard
-
-
-	preprocessor.token_begin = begin
-	preprocessor.token_end = end
-	return contents
-
-blck_block.doc = ( # type: ignore
-	"""
-	Block used to restrict action/defs/labels... to a local part of the files
-	Can be very useful to wrap an include
-
-	usage: block [--options]
-
-	options:
-	  -b --begin <string>  change the begin token (default is same as current)
-	  -e --end <string>    change the end token (default is same as current)
-	  -d --local-defs      commands defined and undefined in the block are local
-	  -a --local-actions   final actions called in the block will only affect the block
-	                       use this to restrict replace, upper, ... to a section
-	  -c --local-clipboard the clipboard defined by cut in the block are local
-	  -l --local-labels    labels defined in the block are local, so they can
-	                       only be written to by local atlabel blocks
-
-	Just like the verbatim block, changing begin and end means that the block will
-	end at the first {% endblock %} not matching a {% block %}:
-
-	  {% block -b < -e > %}
-	    {% block blabla %}
-	    ...
-	    {% endblock %} // this endblock is ignored
-	  {% endblock %} // block ends here
-	""")
-
-def blck_verbatim(preprocessor: Preprocessor, args: str, contents: str) -> str:
-	"""The verbatim block. It copies its content without parsing them
-	Stops at first {% endverbatim %} not matching a {% verbatim %}"""
-	if args.strip() != "":
-		preprocessor.send_warning("extra-arguments", "the verbatim block takes no arguments")
-	return contents
-
-blck_verbatim.doc = ( # type: ignore
-	"""
-	Used to paste contents without parsing them
-	Stops at first {% endverbatim %} not matching a {% verbatim %}.
-
-	Ex:
-	  "{% verbatim %}some text with symbols {% and %}{% endverbatim %}"
-	Prints:
-	  "some text with symbols {% and %}"
-
-	Ex:
-	  "{% verbatim %}some text with {% verbatim %}nested verbatim{% endverbatim %}{% endverbatim %}"
-	Prints:
-	  "some text with {% verbatim %}nested verbatim{% endverbatim %}"
-	""")
-
-def blck_repeat(preprocessor: Preprocessor, args: str, contents: str) -> str:
-	"""The repeat block.
-	usage: repeat <number>
-		renders its contents one and copies them number times"""
-	args = args.strip()
-	if not args.isnumeric():
-		preprocessor.send_error("invalid-argument", "invalid argument. Usage: repeat [uint > 0]")
-	number = int(args)
-	if number <= 0:
-		preprocessor.send_error("invalid-argument", "invalid argument. Usage: repeat [uint > 0]")
-	preprocessor.context.update(preprocessor.current_position.end, "in block repeat")
-	contents = preprocessor.parse(contents)
-	preprocessor.context.pop()
-	return contents * number
-
-blck_repeat.doc = ( # type: ignore
-	"""
-	Used to repeat a block of text a number of times
-
-	Usage: repeat <number>
-
-	Ex: "{% repeat 4 %}a{% endrepeat %}" prints "aaaa".
-
-	Unlike {% for x in range(3) %}, {% repeat 3 %} only
-	  renders the block once and prints three copies.
-	""")
+
+class Blck_Comment(Block):
+    def __call__(self, preprocessor: Preprocessor, args: str, _contents: str) -> str:
+        """The comment block, ignores its contents"""
+        if args.strip() != "":
+            preprocessor.send_warning(
+                "extra-arguments", "the void block takes no arguments"
+            )
+        return ""
+
+    doc = """
+        This block is a comment.
+        All text until the next 'endcomment' is ignored"""
+
+
+class Blck_Void(Block):
+    def __call__(self, preprocessor: Preprocessor, args: str, contents: str) -> str:
+        """The void block, processes commands inside it but prints nothing"""
+        if args.strip() != "":
+            preprocessor.send_warning(
+                "extra-arguments", "the void block takes no arguments"
+            )
+        preprocessor.context.update(preprocessor.current_position.end, "in void block")
+        contents = preprocessor.parse(contents)
+        preprocessor.context.pop()
+        return ""
+
+    doc = """
+        This block is parsed but not printed.
+        Use it to place comments or a bunch of def
+        without adding whitespace"""
+
+
+class Blck_Block(Block):
+    parser = ArgumentParserNoExit(prog="block", add_help=False)
+    parser.add_argument("--begin", "-b", nargs="?", default=None)
+    parser.add_argument("--end", "-e", nargs="?", default=None)
+    parser.add_argument("--local-defs", "-d", action="store_true")
+    parser.add_argument("--local-actions", "-a", action="store_true")
+    parser.add_argument("--local-clipboard", "-c", action="store_true")
+    parser.add_argument("--local-labels", "-l", action="store_true")
+
+    def __call__(self, preprocessor: Preprocessor, args: str, contents: str) -> str:
+        """The block block. allows restriction of final actions, defs and
+        clipboard to local block"""
+        split = preprocessor.split_args(args)
+        try:
+            arguments = self.parser.parse_args(split)
+        except argparse.ArgumentError:
+            preprocessor.send_error(
+                "invalid-argument",
+                "invalid argument.\n"
+                "usage: block [--begin|-b <str>] [--end|-e <str>]\n"
+                "             [--local-actions|-a] [--local-defs|-d] [--local-clipboard|-c]",
+            )
+        begin = preprocessor.token_begin
+        end = preprocessor.token_end
+        if arguments.begin is not None:
+            preprocessor.token_begin = arguments.begin
+        if arguments.end is not None:
+            preprocessor.token_end = arguments.end
+        if arguments.local_defs:
+            commands = preprocessor.commands.copy()
+            blocks = preprocessor.blocks.copy()
+            if "def" in preprocessor.command_vars:
+                defs = preprocessor.command_vars["def"].copy()
+            else:
+                defs = dict()
+        if arguments.local_clipboard:
+            if "clipboard" in preprocessor.command_vars:
+                clipboard = preprocessor.command_vars["clipboard"].copy()
+            else:
+                clipboard = dict()
+        if arguments.local_actions:
+            action = preprocessor.final_actions.copy()
+            preprocessor.final_actions = Preprocessor.final_actions.copy()
+        if arguments.local_labels:
+            labels = preprocessor.labels.copy()
+
+        preprocessor.context.update(preprocessor.current_position.end, "in block block")
+        contents = preprocessor.parse(contents)
+        preprocessor.context.pop()
+
+        if arguments.local_actions:
+            contents = preprocessor.run_final_actions(contents)
+            preprocessor.final_actions = action
+        if arguments.local_labels:
+            preprocessor.labels = labels
+            preprocessor.labels.new_level()  # add empty level to pop
+        if arguments.local_defs:
+            preprocessor.commands = commands
+            preprocessor.blocks = blocks
+            preprocessor.command_vars["def"] = defs
+        if arguments.local_clipboard:
+            preprocessor.command_vars["clipboard"] = clipboard
+
+        preprocessor.token_begin = begin
+        preprocessor.token_end = end
+        return contents
+
+    doc = """
+        Block used to restrict action/defs/labels... to a local part of the files
+        Can be very useful to wrap an include
+
+        usage: block [--options]
+
+        options:
+        -b --begin <string>  change the begin token (default is same as current)
+        -e --end <string>    change the end token (default is same as current)
+        -d --local-defs      commands defined and undefined in the block are local
+        -a --local-actions   final actions called in the block will only affect the block
+                            use this to restrict replace, upper, ... to a section
+        -c --local-clipboard the clipboard defined by cut in the block are local
+        -l --local-labels    labels defined in the block are local, so they can
+                            only be written to by local atlabel blocks
+
+        Just like the verbatim block, changing begin and end means that the block will
+        end at the first {% endblock %} not matching a {% block %}:
+
+        {% block -b < -e > %}
+            {% block blabla %}
+            ...
+            {% endblock %} // this endblock is ignored
+        {% endblock %} // block ends here
+        """
+
+
+class Blck_Verbatim(Block):
+    def __call__(self, preprocessor: Preprocessor, args: str, contents: str) -> str:
+        """The verbatim block. It copies its content without parsing them
+        Stops at first {% endverbatim %} not matching a {% verbatim %}"""
+        if args.strip() != "":
+            preprocessor.send_warning(
+                "extra-arguments", "the verbatim block takes no arguments"
+            )
+        return contents
+
+    doc = """
+        Used to paste contents without parsing them
+        Stops at first {% endverbatim %} not matching a {% verbatim %}.
+
+        Ex:
+        "{% verbatim %}some text with symbols {% and %}{% endverbatim %}"
+        Prints:
+        "some text with symbols {% and %}"
+
+        Ex:
+        "{% verbatim %}
+            some text with {% verbatim %}nested verbatim{% endverbatim %}
+        {% endverbatim %}"
+        Prints:
+        "
+            some text with {% verbatim %}nested verbatim{% endverbatim %}
+        "
+        """
+
+
+class Blck_Repeat(Block):
+    def __call__(self, preprocessor: Preprocessor, args: str, contents: str) -> str:
+        """The repeat block.
+        usage: repeat <number>
+                renders its contents one and copies them number times"""
+        args = args.strip()
+        if not args.isnumeric():
+            preprocessor.send_error(
+                "invalid-argument", "invalid argument. Usage: repeat [uint > 0]"
+            )
+        number = int(args)
+        if number <= 0:
+            preprocessor.send_error(
+                "invalid-argument", "invalid argument. Usage: repeat [uint > 0]"
+            )
+        preprocessor.context.update(
+            preprocessor.current_position.end, "in block repeat"
+        )
+        contents = preprocessor.parse(contents)
+        preprocessor.context.pop()
+        return contents * number
+
+    doc = """
+        Used to repeat a block of text a number of times
+
+        Usage: repeat <number>
+
+        Ex: "{% repeat 4 %}a{% endrepeat %}" prints "aaaa".
+
+        Unlike {% for x in range(3) %}, {% repeat 3 %} only
+        renders the block once and prints three copies.
+        """
 
 
 # ============================================================
 # atlabel block
 # ============================================================
 
 
-def blck_atlabel(preprocessor: Preprocessor, args: str, contents: str) -> str:
-	"""the atlabel block
-	usage: atlabel <label>
-	renders its contents and stores them
-	add a post action to place itself at all labels <label>"""
-	lbl = args.strip()
-	if lbl == "":
-		preprocessor.send_error("invalid-label", "empty label name")
-	if "atlabel" in preprocessor.command_vars:
-		if lbl in preprocessor.command_vars["atlabel"]:
-			preprocessor.send_error("atlabel-conflict",
-				'Multiple atlabel blocks with same label "{}"'.format(lbl)
-			)
-	else:
-		preprocessor.command_vars["atlabel"] = dict()
-
-	preprocessor.context.update(preprocessor.current_position.end, "in block atlabel")
-	preprocessor.command_vars["atlabel"][lbl] = preprocessor.parse(contents)
-	preprocessor.context.pop()
-	return ""
-
-blck_atlabel.doc = ( # type: ignore
-	"""
-	Renders a chunk of text and places it at all labels matching
-	its label when processing is done.
-
-	Usage: atlabel <label>
-
-	It differs from the cut block in that:
-	- it will also print its content to calls of {% label XXX %} preceding it
-	- it canno't be overwritting (at most one atlabel block per label)
-	- the text is rendered in the block (and not in where the text is pared)
-
-	ex:
-	  "{% def foo bar %}
-	  first label: {% label my_label %}
-	  {% atlabel my_label %}foo is {% foo %}{% endatlabel %}
-		{% def foo notbar %}
-	  second label: {% label my_label %}"
-	prints:
-	  "
-	  first label: foo is bar
-
-	  second label: foo is bar"
-
-	Can be used in combination with include to create files inheriting
-	from a common base.
-	""")
-
-def fnl_atlabel(preprocessor: Preprocessor, string: str) -> str:
-	"""places atlabel blocks at all matching labels"""
-	if "atlabel" in preprocessor.command_vars:
-		deletions = []
-		for lbl in preprocessor.command_vars["atlabel"]:
-			nb_labels = len(preprocessor.labels.get_label(lbl))
-			if nb_labels == 0:
-				preprocessor.send_warning("unplaced-atlabel",
-					'No matching label for atlabel block "{}"'.format(lbl)
-				)
-			for i in range(nb_labels):
-				# use references to labels because of offsets
-				index = preprocessor.labels.get_label(lbl)[i]
-				string = preprocessor.replace_string(
-					index, index, string, preprocessor.command_vars["atlabel"][lbl], []
-				)
-			deletions.append(lbl)
-		for lbl in deletions:
-			del preprocessor.command_vars["atlabel"][lbl]
-	return string
+class Blck_Atlabel(Block):
+    def __call__(self, preprocessor: Preprocessor, args: str, contents: str) -> str:
+        """the atlabel block
+        usage: atlabel <label>
+        renders its contents and stores them
+        add a post action to place itself at all labels <label>"""
+        lbl = args.strip()
+        if lbl == "":
+            preprocessor.send_error("invalid-label", "empty label name")
+        if "atlabel" in preprocessor.command_vars:
+            if lbl in preprocessor.command_vars["atlabel"]:
+                preprocessor.send_error(
+                    "atlabel-conflict",
+                    'Multiple atlabel blocks with same label "{}"'.format(lbl),
+                )
+        else:
+            preprocessor.command_vars["atlabel"] = dict()
+
+        preprocessor.context.update(
+            preprocessor.current_position.end, "in block atlabel"
+        )
+        preprocessor.command_vars["atlabel"][lbl] = preprocessor.parse(contents)
+        preprocessor.context.pop()
+        return ""
+
+    doc = """
+        Renders a chunk of text and places it at all labels matching
+        its label when processing is done.
+
+        Usage: atlabel <label>
+
+        It differs from the cut block in that:
+        - it will also print its content to calls of {% label XXX %} preceding it
+        - it canno't be overwritting (at most one atlabel block per label)
+        - the text is rendered in the block (and not in where the text is pared)
+
+        ex:
+        "{% def foo bar %}
+        first label: {% label my_label %}
+        {% atlabel my_label %}foo is {% foo %}{% endatlabel %}
+            {% def foo notbar %}
+        second label: {% label my_label %}"
+        prints:
+        "
+        first label: foo is bar
+
+        second label: foo is bar"
+
+        Can be used in combination with include to create files inheriting
+        from a common base.
+        """
+
+
+class Fnl_AtLabel(Command):
+    def __call__(self, preprocessor: Preprocessor, string: str) -> str:
+        """places atlabel blocks at all matching labels"""
+        if "atlabel" in preprocessor.command_vars:
+            deletions = []
+            for lbl in preprocessor.command_vars["atlabel"]:
+                nb_labels = len(preprocessor.labels.get_label(lbl))
+                if nb_labels == 0:
+                    preprocessor.send_warning(
+                        "unplaced-atlabel",
+                        'No matching label for atlabel block "{}"'.format(lbl),
+                    )
+                for i in range(nb_labels):
+                    # use references to labels because of offsets
+                    index = preprocessor.labels.get_label(lbl)[i]
+                    string = preprocessor.replace_string(
+                        index,
+                        index,
+                        string,
+                        preprocessor.command_vars["atlabel"][lbl],
+                        [],
+                    )
+                deletions.append(lbl)
+            for lbl in deletions:
+                del preprocessor.command_vars["atlabel"][lbl]
+        return string
 
 
 # ============================================================
 # for block
 # ============================================================
 
 
-def blck_for(preprocessor: Preprocessor, args: str, contents: str) -> str:
-	"""The for block, simple for loop
-	usage: for <ident> in range(stop)
-	                      range(start, stop)
-	                      range(start, stop, step)
-	       for <ident> in space separated list " argument with spaces"
-	"""
-	match = re.match(r"^\s*({})\s+in\s+".format(REGEX_IDENTIFIER), args)
-	if match is None:
-		preprocessor.send_error("invalid-argument",
-			"Invalid syntax.\n"
-			"usage: for <ident> in range(stop)\n"
-	    "                      range(start, stop)\n"
-			"                      range(start, stop, step)\n"
-			"       for <ident> in space separated list \" argument with spaces\""
-		)
-		return ""
-	ident = match.group(1)
-	args = args[match.end():].strip()
-	iterator: Iterable = []
-	if args[0:5] == "range":
-		regex = r"range\((?:\s*({nb})\s*,)?\s*({nb})\s*(?:,\s*({nb})\s*)?\)".format(
-			nb = REGEX_INTEGER)
-		match = re.match(regex, args)
-		if match is None:
-			preprocessor.send_error("invalid-argument",
-				"Invalid range syntax in for.\n"
-				"usage: range(stop) or range(start, stop) or range(start, stop, step)\n"
-				"  start, stop and step, should be integers (contain only 0-9 or _, with an optional leading -)"
-			)
-			return ""
-		groups = match.groups()
-		start = 0
-		step = 1
-		stop = to_integer(groups[1])
-		if groups[0] is not None:
-			start = to_integer(groups[0])
-			if groups[2] is not None:
-				step = to_integer(groups[2])
-		iterator = range(start, stop, step)
-	else:
-		iterator = preprocessor.split_args(args)
-	result = ""
-	for value in iterator:
-		def defined_value(preproc: Preprocessor, args: str) -> str:
-			"""new command defined in for block"""
-			if args.strip() != "":
-				preproc.send_warning("extra-arguments",
-					"Extra arguments.\nThe command {} defined in for loop takes no arguments".format(ident)
-				)
-			return str(value)
-		defined_value.__name__ = "for_cmd_{}".format(ident)
-		defined_value.__doc__ = "Command defined in for loop: {} = '{}'".format(ident, value)
-		defined_value.doc = defined_value.__doc__ # type: ignore
-		preprocessor.commands[ident] = defined_value
-		preprocessor.context.update(preprocessor.current_position.end, "in for block")
-		result += preprocessor.parse(contents)
-		preprocessor.context.pop()
-	return result
-
-blck_for.doc = ( # type: ignore
-	"""
-	Simple for loop used to render a chunk of text multiple times.
-	ex: "{% for x in range(2) %}{% x %},{% endfor %}" -> "1,2,"
-
-	Usage: for <ident> in range(stop)
-	                      range(start, stop)
-	                      range(start, stop, step)
-	       for <ident> in space separated list " argument with spaces"
-
-
-	range can be combined with the deflist command to iterate multiple lists:
-
-	  "{% deflist names alice john frank %} {% deflist ages 23 31 19 %}
-	  {% for i in range(3) %}{% names {% i %} %} (age {% ages {% i %} %})
-	  {% endfor %}"
-
-	prints:
-
-	  "
-	  alice (age 23)
-	  john (age 31)
-	  frank (age 19)
-	  "
+class Blck_For(Block):
+    def __call__(self, preprocessor: Preprocessor, args: str, contents: str) -> str:
+        """The for block, simple for loop
+        usage: for <ident> in range(stop)
+                            range(start, stop)
+                            range(start, stop, step)
+            for <ident> in space separated list " argument with spaces"
+        """
+        match = re.match(r"^\s*({})\s+in\s+".format(REGEX_IDENTIFIER), args)
+        if match is None:
+            preprocessor.send_error(
+                "invalid-argument",
+                "Invalid syntax.\n"
+                "usage: for <ident> in range(stop)\n"
+                "                      range(start, stop)\n"
+                "                      range(start, stop, step)\n"
+                '       for <ident> in space separated list " argument with spaces"',
+            )
+            return ""
+        ident = match.group(1)
+        args = args[match.end() :].strip()
+        iterator: Iterable[Any] = []
+        if args[0:5] == "range":
+            regex = r"range\((?:\s*({nb})\s*,)?\s*({nb})\s*(?:,\s*({nb})\s*)?\)".format(
+                nb=REGEX_INTEGER
+            )
+            match = re.match(regex, args)
+            if match is None:
+                preprocessor.send_error(
+                    "invalid-argument",
+                    "Invalid range syntax in for.\n"
+                    "usage: range(stop) or range(start, stop) or range(start, stop, step)\n"
+                    "  start, stop and step, should be integers (contain only 0-9 or _,"
+                    " with an optional leading -)",
+                )
+                return ""
+            groups = match.groups()
+            start = 0
+            step = 1
+            stop = to_integer(groups[1])
+            if groups[0] is not None:
+                start = to_integer(groups[0])
+                if groups[2] is not None:
+                    step = to_integer(groups[2])
+            iterator = range(start, stop, step)
+        else:
+            iterator = preprocessor.split_args(args)
+        result = ""
+        for value in iterator:
+
+            class Defined_Value(Command):
+                def __call__(self, preproc: Preprocessor, args: str) -> str:
+                    """new command defined in for block"""
+                    if args.strip() != "":
+                        preproc.send_warning(
+                            "extra-arguments",
+                            (
+                                "Extra arguments.\nThe command {} defined in for loop takes"
+                                " no arguments"
+                            ).format(ident),
+                        )
+                    return str(value)
+
+                name = "for_cmd_{}".format(ident)
+                doc = "Command defined in for loop: {} = '{}'".format(ident, value)
+
+            preprocessor.commands[ident] = Defined_Value()
+            preprocessor.context.update(
+                preprocessor.current_position.end, "in for block"
+            )
+            result += preprocessor.parse(contents)
+            preprocessor.context.pop()
+        return result
+
+    doc = """
+        Simple for loop used to render a chunk of text multiple times.
+        ex: "{% for x in range(2) %}{% x %},{% endfor %}" -> "1,2,"
+
+        Usage: for <ident> in range(stop)
+                            range(start, stop)
+                            range(start, stop, step)
+            for <ident> in space separated list " argument with spaces"
+
+
+        range can be combined with the deflist command to iterate multiple lists:
+
+        "{% deflist names alice john frank %} {% deflist ages 23 31 19 %}
+        {% for i in range(3) %}{% names {% i %} %} (age {% ages {% i %} %})
+        {% endfor %}"
+
+        prints:
+
+        "
+        alice (age 23)
+        john (age 31)
+        frank (age 19)
+        "
 
-	""")
+        """
 
 
 # ============================================================
 # cut block
 # ============================================================
 
 
-cut_parser = ArgumentParserNoExit(prog="cut", add_help=False)
-cut_parser.add_argument("--pre-render", "-p", action="store_true")
-cut_parser.add_argument("clipboard", nargs="?", default="")
-
-def blck_cut(preprocessor: Preprocessor, args: str, contents: str) -> str:
-	"""the cut block.
-	usage: cut [--pre-render|-p] [<clipboard_name>]
-		if --pre-render - renders the block here
-		  (will be rerendered at time of pasting, unless using paste -v|--verbatim)
-		clipboard is a string identifying the clipboard, default is ""
-	"""
-	split = preprocessor.split_args(args)
-	try:
-		arguments = cut_parser.parse_args(split)
-	except argparse.ArgumentError:
-		preprocessor.send_error("invalid-argument",
-			"invalid argument.\nusage: cut [--pre-render|-p] [<clipboard_name>]"
-		)
-	clipboard = arguments.clipboard
-	pos = preprocessor.current_position.end
-	context = preprocessor.context.top.copy(pos, "in pasted block")
-	if arguments.pre_render:
-		preprocessor.context.update(pos, "in cut block")
-		contents = preprocessor.parse(contents)
-		preprocessor.context.pop()
-	if "clipboard" not in preprocessor.command_vars:
-		preprocessor.command_vars["clipboard"] = {clipboard: (context, contents)}
-	else:
-		preprocessor.command_vars["clipboard"][clipboard] = (context, contents)
-	return ""
-
-blck_cut.doc = ( # type: ignore
-	"""
-	Used to cut a section of text to paste elsewhere.
-	The text is processed when pasted, not when cut
-
-	Usage: cut [--pre-render|-p] [<clipboard_name>]
-	  if --pre-render - renders the block here
-	    (will be rerendered at time of pasting, unless using paste -v|--verbatim)
-	  clipboard is a string identifying the clipboard, default is ""
-
-	ex:
-	  {% cut %}foo is {% foo %}{% endcut %}
-	  {% def foo bar %}
-	  first paste: {% paste %}
-	  {% def foo notbar %}
-	  second paste: {% paste %}"
-	prints:
-	  "
+class Blck_Cut(Block):
+    parser = ArgumentParserNoExit(prog="cut", add_help=False)
+    parser.add_argument("--pre-render", "-p", action="store_true")
+    parser.add_argument("clipboard", nargs="?", default="")
+
+    def __call__(self, preprocessor: Preprocessor, args: str, contents: str) -> str:
+        """the cut block.
+        usage: cut [--pre-render|-p] [<clipboard_name>]
+                if --pre-render - renders the block here
+                (will be rerendered at time of pasting, unless using paste -v|--verbatim)
+                clipboard is a string identifying the clipboard, default is ""
+        """
+        split = preprocessor.split_args(args)
+        try:
+            arguments = self.parser.parse_args(split)
+        except argparse.ArgumentError:
+            preprocessor.send_error(
+                "invalid-argument",
+                "invalid argument.\nusage: cut [--pre-render|-p] [<clipboard_name>]",
+            )
+        clipboard = arguments.clipboard
+        pos = preprocessor.current_position.end
+        context = preprocessor.context.top.copy(pos, "in pasted block")
+        if arguments.pre_render:
+            preprocessor.context.update(pos, "in cut block")
+            contents = preprocessor.parse(contents)
+            preprocessor.context.pop()
+        if "clipboard" not in preprocessor.command_vars:
+            preprocessor.command_vars["clipboard"] = {clipboard: (context, contents)}
+        else:
+            preprocessor.command_vars["clipboard"][clipboard] = (context, contents)
+        return ""
+
+    doc = """
+        Used to cut a section of text to paste elsewhere.
+        The text is processed when pasted, not when cut
+
+        Usage: cut [--pre-render|-p] [<clipboard_name>]
+        if --pre-render - renders the block here
+            (will be rerendered at time of pasting, unless using paste -v|--verbatim)
+        clipboard is a string identifying the clipboard, default is ""
+
+        ex:
+        {% cut %}foo is {% foo %}{% endcut %}
+        {% def foo bar %}
+        first paste: {% paste %}
+        {% def foo notbar %}
+        second paste: {% paste %}"
+        prints:
+        "
 
-	  first paste: foo is bar
+        first paste: foo is bar
 
-	  second paste: foo is notbar"
-	""")
+        second paste: foo is notbar"
+        """
 
 
 # ============================================================
 # if block
 # ============================================================
 
-def find_elifs_and_else(preproc: Preprocessor, string: str
-	) -> Tuple[int, int, Optional[str]]:
-	"""returns a tuple indicating the next elif/else:
-	(-1,-1,None) -> no matching elif/else
-	(begin, end, None) -> matching else at string[begin:end]
-	(begin, end, str) -> matchin elif with arguments str at string[begin:end]"""
-	tokens = preproc._find_tokens(string)
-	depth = 0
-	endif_regex = r"\s*{}if\s*{}".format(
-		re.escape(preproc.token_endblock),
-		re.escape(preproc.token_end)
-	)
-	if_regex = r"\s*if(?:{}|{})".format(
-		re.escape(preproc.token_end), REGEX_IDENTIFIER_END
-	)
-	elif_regex = r"\s*(elif)(?:{}|{})".format(
-		re.escape(preproc.token_end), REGEX_IDENTIFIER_END
-	)
-	else_regex = r"\s*else\s*{}".format(re.escape(preproc.token_end))
-	for i, (begin, end, token) in enumerate(tokens):
-		if token == TokenMatch.OPEN:
-			if re.match(if_regex, string[end:], preproc.re_flags) is not None:
-				depth += 1
-			elif re.match(endif_regex, string[end:], preproc.re_flags) is not None:
-				depth -= 1
-			elif depth == 0:
-				match_else = re.match(else_regex, string[end:], preproc.re_flags)
-				match_elif = re.match(elif_regex, string[end:], preproc.re_flags)
-				if match_else is not None:
-					return (begin, end + match_else.end(), None)
-				if match_elif is not None:
-					parenthese = ["(" if x[2] == TokenMatch.OPEN else ")" for x in tokens]
-					j = find_matching_close_parenthese(parenthese, i)
-					if j == len(tokens):
-						preproc.context.update(begin + preproc.current_position.end, "in elif")
-						preproc.send_error("unmatched-open-token",
-							'Unmatched "{}" token in endif.\n'
-							'Add matching "{}" or use "{}begin{}" to place it.'.format(
-							preproc.token_begin, preproc.token_end, preproc.token_begin, preproc.token_end
-						))
-						preproc.context.pop()
-					end += match_elif.end(1)
-					return (begin, tokens[j][1], string[end:tokens[j][0]])
-	return (-1, -1, None)
-
-def blck_if(preprocessor: Preprocessor, args: str, contents: str) -> str:
-	"""the if block
-	usage: {% if <condition> %} ...
-	       [{% elif <condition> %} ...]
-	       [{% else %}...]
-	       {% endif %}
-	"""
-	value = condition_eval(preprocessor, args)
-	pos_0 = 0
-	desc = "in if block"
-	while True:
-		else_info = find_elifs_and_else(preprocessor, contents[pos_0:])
-		if value:
-			endelse = pos_0 + else_info[0] if else_info[0] != -1 else len(contents)
-			preprocessor.context.update(pos_0 + preprocessor.current_position.end, desc)
-			parsed = preprocessor.parse(contents[pos_0:endelse])
-			preprocessor.context.pop()
-			return parsed
-		if else_info[0] == -1:
-			# no matching else
-			return ""
-		if else_info[2] is None:
-			value = not value
-			desc = "in else"
-		else:
-			preprocessor.context.update(
-				pos_0 + else_info[0] + preprocessor.current_position.end,
-				"in elif evaluation"
-			)
-			args = preprocessor.parse(else_info[2])
-			preprocessor.context.pop()
-			value = condition_eval(preprocessor, args)
-			desc = "in elif"
-		pos_0 += else_info[1]
-
-blck_if.doc = ( # type: ignore
-	"""
-	Used to select wether or not to render a chunk of text
-	based on simple conditions
-	ex :
-	  {% if def identifier %}, {% if ndef identifier %}...
-	  {% if {% var %}==str_value %}, {% if {% var %}!=str_value %}...
-
-	Usage: {% if <condition> %} ...
-	       [{% elif <condition> %} ...]
-	       [{% else %}...]
-	       {% endif %}
-
-	Condition syntax is as follows
-	  simple_condition =
-	    | true | false | 1 | 0 | <string>
-	    | def <identifier> | ndef <identifier>
-	    | <str> == <str> | <str> != <str>
-
-	  condition =
-	    | <simple_condition> | not <simple_condition>
-	    | <condition> and <condition>
-	    | <condition> or <condition>
-	    | (<condition>)
-	""")
+
+class Blck_If(Block):
+    def find_elifs_and_else(
+        self, preproc: Preprocessor, string: str
+    ) -> Tuple[int, int, Optional[str]]:
+        """returns a tuple indicating the next elif/else:
+        (-1,-1,None) -> no matching elif/else
+        (begin, end, None) -> matching else at string[begin:end]
+        (begin, end, str) -> matchin elif with arguments str at string[begin:end]"""
+        tokens = preproc._find_tokens(string)
+        depth = 0
+        endif_regex = r"\s*{}if\s*{}".format(
+            re.escape(preproc.token_endblock), re.escape(preproc.token_end)
+        )
+        if_regex = r"\s*if(?:{}|{})".format(
+            re.escape(preproc.token_end), REGEX_IDENTIFIER_END
+        )
+        elif_regex = r"\s*(elif)(?:{}|{})".format(
+            re.escape(preproc.token_end), REGEX_IDENTIFIER_END
+        )
+        else_regex = r"\s*else\s*{}".format(re.escape(preproc.token_end))
+        for i, (begin, end, token) in enumerate(tokens):
+            if token == TokenMatch.OPEN:
+                if re.match(if_regex, string[end:], preproc.re_flags) is not None:
+                    depth += 1
+                elif re.match(endif_regex, string[end:], preproc.re_flags) is not None:
+                    depth -= 1
+                elif depth == 0:
+                    match_else = re.match(else_regex, string[end:], preproc.re_flags)
+                    match_elif = re.match(elif_regex, string[end:], preproc.re_flags)
+                    if match_else is not None:
+                        return (begin, end + match_else.end(), None)
+                    if match_elif is not None:
+                        parenthese = [
+                            "(" if x[2] == TokenMatch.OPEN else ")" for x in tokens
+                        ]
+                        j = find_matching_close_parenthese(parenthese, i)
+                        if j == len(tokens):
+                            preproc.context.update(
+                                begin + preproc.current_position.end, "in elif"
+                            )
+                            preproc.send_error(
+                                "unmatched-open-token",
+                                'Unmatched "{}" token in endif.\n'
+                                'Add matching "{}" or use "{}begin{}" to place it.'.format(
+                                    preproc.token_begin,
+                                    preproc.token_end,
+                                    preproc.token_begin,
+                                    preproc.token_end,
+                                ),
+                            )
+                            preproc.context.pop()
+                        end += match_elif.end(1)
+                        return (begin, tokens[j][1], string[end : tokens[j][0]])
+        return (-1, -1, None)
+
+    def __call__(self, preprocessor: Preprocessor, args: str, contents: str) -> str:
+        """the if block
+        usage: {% if <condition> %} ...
+            [{% elif <condition> %} ...]
+            [{% else %}...]
+            {% endif %}
+        """
+        value = condition_eval(preprocessor, args)
+        pos_0 = 0
+        desc = "in if block"
+        while True:
+            else_info = self.find_elifs_and_else(preprocessor, contents[pos_0:])
+            if value:
+                endelse = pos_0 + else_info[0] if else_info[0] != -1 else len(contents)
+                preprocessor.context.update(
+                    pos_0 + preprocessor.current_position.end, desc
+                )
+                parsed = preprocessor.parse(contents[pos_0:endelse])
+                preprocessor.context.pop()
+                return parsed
+            if else_info[0] == -1:
+                # no matching else
+                return ""
+            if else_info[2] is None:
+                value = not value
+                desc = "in else"
+            else:
+                preprocessor.context.update(
+                    pos_0 + else_info[0] + preprocessor.current_position.end,
+                    "in elif evaluation",
+                )
+                args = preprocessor.parse(else_info[2])
+                preprocessor.context.pop()
+                value = condition_eval(preprocessor, args)
+                desc = "in elif"
+            pos_0 += else_info[1]
+
+    doc = """
+        Used to select wether or not to render a chunk of text
+        based on simple conditions
+        ex :
+        {% if def identifier %}, {% if ndef identifier %}...
+        {% if {% var %}==str_value %}, {% if {% var %}!=str_value %}...
+
+        Usage: {% if <condition> %} ...
+            [{% elif <condition> %} ...]
+            [{% else %}...]
+            {% endif %}
+
+        Condition syntax is as follows
+        simple_condition =
+            | true | false | 1 | 0 | <string>
+            | def <identifier> | ndef <identifier>
+            | <str> == <str> | <str> != <str>
+
+        condition =
+            | <simple_condition> | not <simple_condition>
+            | <condition> and <condition>
+            | <condition> or <condition>
+            | (<condition>)
+        """
```

## mlpproc/commands.py

```diff
@@ -1,634 +1,831 @@
 """
 Definitions of default preprocessor commands
 """
 import argparse
 import re
 from datetime import datetime
-from os.path import abspath, dirname, isfile, join
+from os.path import abspath, dirname, getsize, isfile, join
 from typing import List
 
 from .context import FileDescriptor
-from .defs import *
-from .preprocessor import Preprocessor
+from .defs import (
+    PREPROCESSOR_VERSION,
+    REGEX_IDENTIFIER_WRAPPED,
+    ArgumentParserNoExit,
+    get_identifier_name,
+    is_integer,
+    process_string,
+    to_integer,
+)
+from .preprocessor import Command, Preprocessor
 
 # ============================================================
 # simple commands
 # ============================================================
 
-def cmd_error(preprocessor: Preprocessor, args: str) -> str:
-	"""the error command - raises an error
-	usage: error [msg]"""
-	args = args.strip()
-	if args == "":
-		preprocessor.send_error("manual-error", "raised by error command.")
-	else:
-		preprocessor.send_error("manual-error", "raised by error command.\n{}".format(args))
-	return ""
-
-cmd_error.doc = ( # type: ignore
-	"""
-	Raises an error.
-	Use with if block to raise errors if conditions are not met.
-
-	Usage: error [message]
-	""")
-
-def cmd_warning(preprocessor: Preprocessor, args: str) -> str:
-	"""the warning command - raises a warning
-	usage: warning [msg]"""
-	args = args.strip()
-	if args == "":
-		preprocessor.send_warning("manual-warning", "raised by warning command.")
-	else:
-		preprocessor.send_warning("manual-warning", "raised by warning command.\n{}".format(args))
-	return ""
-
-cmd_warning.doc = ( # type: ignore
-	"""
-	Raises a warning.
-	Use with if block to raise warnings if conditions are not met.
-
-	Usage: warning [message]
-	""")
-
-def cmd_version(preprocessor: Preprocessor, args: str) -> str:
-	"""the version command - prints the preprocessor version"""
-	if args.strip() != "":
-		preprocessor.send_warning("extra-arguments", "the version command takes no arguments")
-	return PREPROCESSOR_VERSION
-
-cmd_version.doc = ( # type: ignore
-	"""
-	Prints the preprocessor version.
-	""")
-
-def cmd_filename(preprocessor: Preprocessor, args: str) -> str:
-	"""the file command - prints the current file name"""
-	if args.strip() != "":
-		preprocessor.send_warning("extra-arguments", "the file command takes no arguments")
-	return preprocessor.context.top.file.filename
-
-cmd_filename.doc = ( # type: ignore
-	"""
-	Prints the name of the current file being parsed.
-	""")
-
-def cmd_line(preprocessor: Preprocessor, args: str) -> str:
-	"""the line command - prints the current line number"""
-	if args.strip() != "":
-		preprocessor.send_warning("extra-arguments", "the line command takes no arguments")
-	context = preprocessor.context.top
-	pos = context.true_position(preprocessor.current_position.begin)
-	return str(context.file.line_number(pos)[0])
-
-cmd_line.doc = ( # type: ignore
-	"""
-	Prints the current line number.
-	This is the line number of the command in the input file, the line
-	in the output file may differ due to insertions/deletions.
-	""")
+
+class Cmd_Error(Command):
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the error command - raises an error
+        usage: error [msg]"""
+        args = args.strip()
+        if args == "":
+            preprocessor.send_error("manual-error", "raised by error command.")
+        else:
+            preprocessor.send_error(
+                "manual-error", "raised by error command.\n{}".format(args)
+            )
+        return ""
+
+    doc = """
+        Raises an error.
+        Use with if block to raise errors if conditions are not met.
+
+        Usage: error [message]
+        """
+
+
+class Cmd_Warning(Command):
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the warning command - raises a warning
+        usage: warning [msg]"""
+        args = args.strip()
+        if args == "":
+            preprocessor.send_warning("manual-warning", "raised by warning command.")
+        else:
+            preprocessor.send_warning(
+                "manual-warning", "raised by warning command.\n{}".format(args)
+            )
+        return ""
+
+    doc = """
+        Raises a warning.
+        Use with if block to raise warnings if conditions are not met.
+
+        Usage: warning [message]
+        """
+
+
+class Cmd_Version(Command):
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the version command - prints the preprocessor version"""
+        if args.strip() != "":
+            preprocessor.send_warning(
+                "extra-arguments", "the version command takes no arguments"
+            )
+        return PREPROCESSOR_VERSION
+
+    doc = """
+        Prints the preprocessor version.
+        """
+
+
+class Cmd_Filename(Command):
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the file command - prints the current file name"""
+        if args.strip() != "":
+            preprocessor.send_warning(
+                "extra-arguments", "the file command takes no arguments"
+            )
+        return preprocessor.context.top.file.filename
+
+    doc = """
+        Prints the name of the current file being parsed.
+        """
+
+
+class Cmd_Line(Command):
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the line command - prints the current line number"""
+        if args.strip() != "":
+            preprocessor.send_warning(
+                "extra-arguments", "the line command takes no arguments"
+            )
+        context = preprocessor.context.top
+        pos = context.true_position(preprocessor.current_position.begin)
+        return str(context.file.line_number(pos)[0])
+
+    doc = """
+        Prints the current line number.
+        This is the line number of the command in the input file, the line
+        in the output file may differ due to insertions/deletions.
+        """
+
 
 # ============================================================
 # def/undef
 # ============================================================
 
 
+def rreplace(string: str, old: str, new: str, occurrence: int = 1) -> str:
+    """replace <occurrence> number of old by new in string
+    starting with the right"""
+    split = string.rsplit(old, occurrence)
+    return new.join(split)
+
+
 macro_parser = ArgumentParserNoExit(prog="macro", add_help=False)
-macro_parser.add_argument('vars', nargs='*') # arbitrary number of arguments
+macro_parser.add_argument("vars", nargs="*")  # arbitrary number of arguments
+
 
-def rreplace(string, old, new, occurrence = 1):
-	"""replace <occurrence> number of old by new in string
-	starting with the right"""
-	split = string.rsplit(old, occurrence)
-	return new.join(split)
-
-def define_macro(preprocessor: Preprocessor, name: str, args: List[str], text: str) -> None:
-	"""Defines a macro.
-	Inputs:
-	- preprocessor - the object to which the macro is added
-	- name: str - the name of the new macro
-	- args: List[str] - List or arguments name
-	- text: str - the text the command prints. Occurrences of args will
-	  be replaced by the corresponding value during the call.
-	  will only replace occurrence that aren't part of a larger word
-	"""
-	# replace arg occurences with placeholder
-	for i, arg in enumerate(args):
-		text = re.sub(
-			REGEX_IDENTIFIER_WRAPPED.format(re.escape(arg)), # pattern
-			"\\1{}\\3".format("\000(arg {})\000".format(i)), # placeholder
-			text,
-			flags = re.MULTILINE
-		)
-	# define the command
-	def cmd(pre: Preprocessor, cmd_args: List[str], text: str = text, ident: str = name) -> str:
-		"""a defined macro command"""
-		for i, arg in enumerate(cmd_args):
-			pattern = re.escape("\000(arg {})\000".format(i))
-			text = re.sub(pattern, arg, text, flags=re.MULTILINE)
-
-		pre.context.update(
-			pre.current_position.cmd_argbegin,
-			'in expansion of defined command {}'.format(ident)
-		)
-		parsed = pre.parse(text)
-		pre.context.pop()
-		return parsed
-
-	cmd.doc = "{} {}".format(name, " ".join(args)) # type: ignore
-	# place it in command_vars
-	if "def" not in preprocessor.command_vars:
-		preprocessor.command_vars["def"] = dict()
-	preprocessor.command_vars["def"]["{}:{}".format(name, len(args))] = cmd
-
-	overloads = []
-	usages = []
-	for key, val in preprocessor.command_vars["def"].items():
-		if key.startswith(name+":"):
-			overloads.append(int(key[key.find(":") + 1]))
-			usages.append(val.doc)
-	usage = "usage: " + "\n       ".join(usages)
-	overload_nb = rreplace(", ".join(str(x) for x in sorted(overloads)), ", ", " or ")
-
-	# overwrite defined command
-	def defined_cmd(pre: Preprocessor, args_string: str) -> str:
-		"""This is the actual command, parses arguments
-		and calls the correct overload"""
-		split = pre.split_args(args_string)
-		try:
-			arguments = macro_parser.parse_args(split)
-		except argparse.ArgumentError:
-			pre.send_error("invalid-argument",
-				"invalid argument for macro.\n{}".format(usage)
-			)
-		if len(arguments.vars) not in overloads:
-			pre.send_error("invalid-argument",(
-				"invalid number of arguments for macro.\nexpected {} got {}.\n"
-				"{}").format(overload_nb, len(arguments.vars), usage)
-			)
-		return pre.command_vars["def"]["{}:{}".format(name, len(arguments.vars))](
-			pre, arguments.vars
-		)
-
-	defined_cmd.__doc__ = "Defined command for {} (expects {} arguments)\n{}".format(
-		name, overload_nb, usage
-	)
-	defined_cmd.doc = defined_cmd.__doc__ # type: ignore
-	defined_cmd.__name__ = """def_cmd_{}""".format(name)
-
-	preprocessor.commands[name] = defined_cmd
-
-def cmd_def(preprocessor: Preprocessor, args_string : str) -> str:
-	"""the define command - inspired by the C preprocessor's define
-	usage:
-		def <ident> <replacement> -> defines ident with replacement
-			(strips leading/trailing space)
-		def <ident> " replacement with leading/trailing space  "
-		def <ident>(<ident1>, <ident2>) replacement
-			defines a macro"""
-	ident, text, _ = get_identifier_name(args_string)
-	if ident == "":
-		preprocessor.send_error("invalid-identifier",
-			"invalid identifier.\ndef needs a valid identifier, got \"{}\"".format(args_string)
-		)
-
-	# removed trailing\leading whitespace
-	text = text.strip()
-	args = []
-
-	if text and text[0] == "(":
-		end = text.find(")")
-		if end == -1:
-			preprocessor.send_error("unmatched-open-parenthese",
-				'no matching closing ")" in macro definition\n'
-				'Enclose in quotes to have a paranthese as first character'
-			)
-		args = text[1:end].split(",")
-		len_args = len(args)
-		for i in range(len_args):
-			args[i] = args[i].strip()
-			if not args[i].isidentifier():
-				preprocessor.send_error("invalid-identifier",
-					'in def {}: invalid macro parameter name "{}"'.format(ident, args[i])
-				)
-		for arg in args:
-			if args.count(arg) > 1:
-				preprocessor.send_error("invalid-identifier",
-					'in def {}: multiple macro parameters with same name "{}"'.format(ident, arg)
-				)
-		text = text[end+1:].strip()
-
-	# if its a string - use escapes and remove external quotes
-	if len(text) >= 2 and text[0] in preprocessor.string_delimiters and text[-1] == text[0]:
-		text = process_string(text[1:-1])
-
-	define_macro(preprocessor, ident, args, text)
-	return ""
-
-cmd_def.doc = ( # type: ignore
-	"""
-	Defines a new command or macro.
-
-	Usage:
-	 def foo               -> defines empty foo command (prints nothing)
-	 def foo   some text   -> {% foo %} prints "some text"
-	                          (strips trailing/leading space)
-	 def foo " some text " -> {% foo %} prints " some text "
-	 def foo(arg1, arg2) text with arg1 and arg2
-	    -> {% foo bar "hi there" %} prints "text with bar and hi there"
-
-	def overwrites old commands and blocks irreversibly.
-	All defs are global, including those comming from subblocks and included files.
-
-	defs can use nesting and recursive calls using command like call, begin and end.
-
-	  {% def name john %}
-
-	  // name is evaluated before def
-	  {% def rec1 {% name %} %}
-
-	  // call evaluated before def, prints {% name %}
-	  // which will be evaluated when define is called
-	  {% def rec2 {% call name %} %}
-
-	  // 1rst call evaluated in define, prints {% call name %}
-	  // which will be evaluated when define is called
-	  {% def rec3 {% call call name %} %}
-
-	  {% def name alice %}
-	  {% rec1 %} -> prints john
-	  {% rec2 %} -> prints alice
-	  {% rec3 %} -> prints {% name %}
-
-	defs can be overloaded on the number of arguments
-
-	  {% def sum(a,b) a+b %}
-	  {% def sum(a)   {% sum a 0 %} %}
-	  {% sum 5 10 %} -> prints 5+10
-	  {% sum 5 %}    -> prints 5+0
-	""")
-
-def cmd_undef(preprocessor: Preprocessor, args_string: str) -> str:
-	"""The undef command, removes commands or blocks
-	from preprocessor.commands and preprocessor.blocks
-	usage: undef <command-name>"""
-	ident = get_identifier_name(args_string)[0]
-	if ident == "":
-		preprocessor.send_error("invalid-identifier",
-			"invalid identifier in undef: \"{}\"".format(args_string)
-		)
-	undefined = False
-	if ident in preprocessor.commands:
-		del preprocessor.commands[ident]
-		undefined = True
-	if ident in preprocessor.blocks:
-		del preprocessor.commands[ident]
-		undefined = True
-	if not undefined:
-		preprocessor.send_warning("aldready-undefined",
-			"can't undef \"{}\", identifier is aldready undefined.".format(ident)
-		)
-	if "def" in preprocessor.command_vars:
-		del_keys = []
-		for key in preprocessor.command_vars:
-			if key.startswith(ident+"<"):
-				del_keys.append(key)
-		for key in del_keys:
-			del preprocessor.command_vars["def"][key]
-	return ""
-
-cmd_undef.doc = ( # type: ignore
-	"""
-	Undefines a command or block.
-	This is irreversible and can undefine built-in commands and blocks.
-
-	Usage: undef name
-	""")
-
-def cmd_deflist(preprocessor: Preprocessor, args_string: str) -> str:
-	"""The deflist command, used to define lists
-	usage: deflist <list_name> space separated list "element with spaces"
-		list_name must be a valid identifier
-
-	Defines a new command list_name such that
-		list_name prints the lists
-		list_name n prints the n-th element (n must be a between -length+1,length+1)
-	"""
-	ident, text, _ = get_identifier_name(args_string)
-	if ident == "":
-		preprocessor.send_error("invalid-identifier",
-			"invalid identifier.\ndeflist needs a valid identifier, got \"{}\"".format(args_string)
-		)
-	defined_list = preprocessor.split_args(text)
-	def defined_command(pre: Preprocessor, args: str) -> str:
-		args = args.strip()
-		if is_integer(args):
-			index = to_integer(args)
-			list_len = len(defined_list)
-			if index <= - list_len or index >= list_len:
-				pre.send_error("invalid-index",
-					"invalid index.\nDefined list {} has length {}, can't access element {}.".format(
-						ident, list_len, index
-					)
-				)
-			return defined_list[index]
-		if args == "":
-			return text
-		pre.send_error("invalid-argument",
-			"invalid argument for defined list \"{}\".\nusage {} [<number>]".format(
-				args, ident)
-		)
-		return ""
-	preprocessor.commands[ident] = defined_command
-	return ""
-
-cmd_deflist.doc = ( # type: ignore
-	"""
-	Defines a new command.
-
-	Usage: deflist list_name space separated list " element with spaces "
-
-	Defines list_name such that:
-		list_name          prints the lists
-		list_name <number> prints the n-th element
-		                   (number must be a between -length+1 and length+1)
+class Cmd_Def(Command):
+    @staticmethod
+    def define_macro(
+        preprocessor: Preprocessor, name: str, args: List[str], text: str
+    ) -> None:
+        """Defines a macro.
+        Inputs:
+        - preprocessor - the object to which the macro is added
+        - name: str - the name of the new macro
+        - args: List[str] - List or arguments name
+        - text: str - the text the command prints. Occurrences of args will
+        be replaced by the corresponding value during the call.
+        will only replace occurrence that aren't part of a larger word
+        """
+        # replace arg occurences with placeholder
+        for i, arg in enumerate(args):
+            text = re.sub(
+                REGEX_IDENTIFIER_WRAPPED.format(re.escape(arg)),  # pattern
+                "\\1{}\\3".format("\000(arg {})\000".format(i)),  # placeholder
+                text,
+                flags=re.MULTILINE,
+            )
+
+        class Defined_Cmd:
+            def __call__(
+                self,
+                pre: Preprocessor,
+                cmd_args: List[str],
+                text: str = text,
+                ident: str = name,
+            ) -> str:
+                """a defined macro command"""
+                for i, arg in enumerate(cmd_args):
+                    pattern = re.escape("\000(arg {})\000".format(i))
+                    text = re.sub(pattern, arg, text, flags=re.MULTILINE)
+
+                pre.context.update(
+                    pre.current_position.cmd_argbegin,
+                    "in expansion of defined command {}".format(ident),
+                )
+                parsed = pre.parse(text)
+                pre.context.pop()
+                return parsed
+
+            doc = "{} {}".format(name, " ".join(args))
+
+        # place it in command_vars
+        if "def" not in preprocessor.command_vars:
+            preprocessor.command_vars["def"] = dict()
+        preprocessor.command_vars["def"][
+            "{}:{}".format(name, len(args))
+        ] = Defined_Cmd()
+
+        overloads = []
+        usages = []
+        for key, val in preprocessor.command_vars["def"].items():
+            if key.startswith(name + ":"):
+                overloads.append(int(key[key.find(":") + 1]))
+                usages.append(val.doc)
+        usage = "usage: " + "\n       ".join(usages)
+        overload_nb = rreplace(
+            ", ".join(str(x) for x in sorted(overloads)), ", ", " or "
+        )
+
+        class Cmd(Command):
+            # overwrite defined command
+
+            def __call__(self, pre: Preprocessor, args_string: str) -> str:
+                """This is the actual command, parses arguments
+                and calls the correct overload"""
+                split = pre.split_args(args_string)
+                try:
+                    arguments = macro_parser.parse_args(split)
+                except argparse.ArgumentError:
+                    pre.send_error(
+                        "invalid-argument",
+                        "invalid argument for macro.\n{}".format(usage),
+                    )
+                if len(arguments.vars) not in overloads:
+                    pre.send_error(
+                        "invalid-argument",
+                        (
+                            "invalid number of arguments for macro.\nexpected {} got {}.\n"
+                            "{}"
+                        ).format(overload_nb, len(arguments.vars), usage),
+                    )
+                return str(
+                    pre.command_vars["def"]["{}:{}".format(name, len(arguments.vars))](
+                        pre, arguments.vars
+                    ),
+                )
+
+            doc = "Defined command for {} (expects {} arguments)\n{}".format(
+                name, overload_nb, usage
+            )
+
+        preprocessor.commands[name] = Cmd()
+
+    def __call__(self, preprocessor: Preprocessor, args_string: str) -> str:
+        """the define command - inspired by the C preprocessor's define
+        usage:
+                def <ident> <replacement> -> defines ident with replacement
+                        (strips leading/trailing space)
+                def <ident> " replacement with leading/trailing space  "
+                def <ident>(<ident1>, <ident2>) replacement
+                        defines a macro"""
+        ident, text, _ = get_identifier_name(args_string)
+        if ident == "":
+            preprocessor.send_error(
+                "invalid-identifier",
+                'invalid identifier.\ndef needs a valid identifier, got "{}"'.format(
+                    args_string
+                ),
+            )
+
+        # removed trailing\leading whitespace
+        text = text.strip()
+        args = []
+
+        if text and text[0] == "(":
+            end = text.find(")")
+            if end == -1:
+                preprocessor.send_error(
+                    "unmatched-open-parenthese",
+                    'no matching closing ")" in macro definition\n'
+                    "Enclose in quotes to have a paranthese as first character",
+                )
+            args = text[1:end].split(",")
+            len_args = len(args)
+            for i in range(len_args):
+                args[i] = args[i].strip()
+                if not args[i].isidentifier():
+                    preprocessor.send_error(
+                        "invalid-identifier",
+                        'in def {}: invalid macro parameter name "{}"'.format(
+                            ident, args[i]
+                        ),
+                    )
+            for arg in args:
+                if args.count(arg) > 1:
+                    preprocessor.send_error(
+                        "invalid-identifier",
+                        'in def {}: multiple macro parameters with same name "{}"'.format(
+                            ident, arg
+                        ),
+                    )
+            text = text[end + 1 :].strip()
+
+        # if its a string - use escapes and remove external quotes
+        if (
+            len(text) >= 2
+            and text[0] in preprocessor.string_delimiters
+            and text[-1] == text[0]
+        ):
+            text = process_string(text[1:-1])
+
+        self.define_macro(preprocessor, ident, args, text)
+        return ""
+
+    doc = """
+        Defines a new command or macro.
+
+        Usage:
+        def foo               -> defines empty foo command (prints nothing)
+        def foo   some text   -> {% foo %} prints "some text"
+                                (strips trailing/leading space)
+        def foo " some text " -> {% foo %} prints " some text "
+        def foo(arg1, arg2) text with arg1 and arg2
+            -> {% foo bar "hi there" %} prints "text with bar and hi there"
+
+        def overwrites old commands and blocks irreversibly.
+        All defs are global, including those comming from subblocks and included files.
+
+        defs can use nesting and recursive calls using command like call, begin and end.
+
+        {% def name john %}
+
+        // name is evaluated before def
+        {% def rec1 {% name %} %}
+
+        // call evaluated before def, prints {% name %}
+        // which will be evaluated when define is called
+        {% def rec2 {% call name %} %}
+
+        // 1rst call evaluated in define, prints {% call name %}
+        // which will be evaluated when define is called
+        {% def rec3 {% call call name %} %}
+
+        {% def name alice %}
+        {% rec1 %} -> prints john
+        {% rec2 %} -> prints alice
+        {% rec3 %} -> prints {% name %}
+
+        defs can be overloaded on the number of arguments
+
+        {% def sum(a,b) a+b %}
+        {% def sum(a)   {% sum a 0 %} %}
+        {% sum 5 10 %} -> prints 5+10
+        {% sum 5 %}    -> prints 5+0
+        """
+
+
+class Cmd_Undef(Command):
+    def __call__(self, preprocessor: Preprocessor, args_string: str) -> str:
+        """The undef command, removes commands or blocks
+        from preprocessor.commands and preprocessor.blocks
+        usage: undef <command-name>"""
+        ident = get_identifier_name(args_string)[0]
+        if ident == "":
+            preprocessor.send_error(
+                "invalid-identifier",
+                'invalid identifier in undef: "{}"'.format(args_string),
+            )
+        undefined = False
+        if ident in preprocessor.commands:
+            del preprocessor.commands[ident]
+            undefined = True
+        if ident in preprocessor.blocks:
+            del preprocessor.commands[ident]
+            undefined = True
+        if not undefined:
+            preprocessor.send_warning(
+                "aldready-undefined",
+                'can\'t undef "{}", identifier is aldready undefined.'.format(ident),
+            )
+        if "def" in preprocessor.command_vars:
+            del_keys = []
+            for key in preprocessor.command_vars:
+                if key.startswith(ident + "<"):
+                    del_keys.append(key)
+            for key in del_keys:
+                del preprocessor.command_vars["def"][key]
+        return ""
+
+    doc = """
+        Undefines a command or block.
+        This is irreversible and can undefine built-in commands and blocks.
+
+        Usage: undef name
+        """
+
+
+class Cmd_Deflist(Command):
+    def __call__(self, preprocessor: Preprocessor, args_string: str) -> str:
+        """The deflist command, used to define lists
+        usage: deflist <list_name> space separated list "element with spaces"
+                list_name must be a valid identifier
+
+        Defines a new command list_name such that
+                list_name prints the lists
+                list_name n prints the n-th element (n must be a between -length+1,length+1)
+        """
+        ident, text, _ = get_identifier_name(args_string)
+        if ident == "":
+            preprocessor.send_error(
+                "invalid-identifier",
+                'invalid identifier.\ndeflist needs a valid identifier, got "{}"'.format(
+                    args_string
+                ),
+            )
+        defined_list = preprocessor.split_args(text)
+
+        class Cmd(Command):
+            def __call__(self, pre: Preprocessor, args: str) -> str:
+                args = args.strip()
+                if is_integer(args):
+                    index = to_integer(args)
+                    list_len = len(defined_list)
+                    if index <= -list_len or index >= list_len:
+                        pre.send_error(
+                            "invalid-index",
+                            (
+                                "invalid index.\nDefined list {} has length {}, can't"
+                                " access element {}."
+                            ).format(ident, list_len, index),
+                        )
+                    return defined_list[index]
+                if args == "":
+                    return text
+                pre.send_error(
+                    "invalid-argument",
+                    'invalid argument for defined list "{}".\nusage {} [<number>]'.format(
+                        args, ident
+                    ),
+                )
+                return ""
+
+        preprocessor.commands[ident] = Cmd()
+        return ""
+
+    doc = """
+        Defines a new command.
+
+        Usage: deflist list_name space separated list " element with spaces "
+
+        Defines list_name such that:
+            list_name          prints the lists
+            list_name <number> prints the n-th element
+                            (number must be a between -length+1 and length+1)
+
+        Can be used in combination with the for block to iterate multiple lists in a loop.
+        """
 
-	Can be used in combination with the for block to iterate multiple lists in a loop.
-	""")
 
 # ============================================================
 # begin/end/call
 # ============================================================
 
 
-def cmd_begin(preprocessor: Preprocessor, args_string: str) -> str:
-	"""The begin command, inserts token_begin
-	usage: begin [uint]
-	  begin -> token_begin
-		begin 0 -> token_begin
-		begin <number> -> token_begin begin <number-1> token_end"""
-	args_string = args_string.strip()
-	level = 0
-	if args_string != "":
-		if args_string.isnumeric():
-			level = int(args_string)
-		else:
-			preprocessor.send_error("invalid-argument","invalid argument: usage begin [uint]")
-		if level < 0:
-			preprocessor.send_error("invalid-argument","invalid argument: usage begin [uint]")
-	if level == 0:
-		return preprocessor.token_begin
-	return preprocessor.token_begin + " begin " + str(level-1) + " " + preprocessor.token_end
-
-cmd_begin.doc = ( # type: ignore
-	"""
-	Prints the current begin token (default "{%")
-
-	Usage: begin [<number>]
-	The optional number is used for recursion calls
-	  begin     -> "{%"
-	  begin 0   -> "{%"
-	  begin <n> -> "{% begin <n-1> %}"
-	""")
-
-def cmd_end(preprocessor: Preprocessor, args_string: str) -> str:
-	"""The end command, inserts token_end
-	usage: end [uint]
-	  end -> token_end
-		end 0 -> token_end
-		end <number> -> token_end end <number-1> token_end"""
-	args_string = args_string.strip()
-	level = 0
-	if args_string != "":
-		if args_string.isnumeric():
-			level = int(args_string)
-		else:
-			preprocessor.send_error("invalid-argument","invalid argument. Usage: end [uint]")
-		if level < 0:
-			preprocessor.send_error("invalid-argument","invalid argument. Usage: end [uint]")
-	if level == 0:
-		return preprocessor.token_end
-	else:
-		return preprocessor.token_begin + " end " + str(level-1) + " " + preprocessor.token_end
-
-cmd_end.doc = ( # type: ignore
-	"""
-	Prints the current end token (default "%}")
-
-	Usage: end [<number>]
-	The optional number is used for recursion calls
-	  end     -> "%}"
-	  end 0   -> "%}"
-	  end <n> -> "{% end <n-1> %}"
-	""")
-
-def cmd_call(preprocessor: Preprocessor, args_string: str) -> str:
-	"""The call command: used to print begin and end tokens
-	usage: {% call foo bar ... %} -> {% foo bar ... %}"""
-	args_string = args_string.strip()
-	if (len(args_string) >= 2 and
-			args_string[0] in preprocessor.string_delimiters and
-			args_string[-1] == args_string[0]):
-		args_string = args_string[1:-1]
-	return preprocessor.token_begin + " " + args_string + " " + preprocessor.token_end
-
-cmd_call.doc = ( # type: ignore
-	"""
-	Prints a call to its arguments.
-
-	Ex: "{% call my_command my_args %}" -> "{% my_command my_args %}"
-	Useful in defs to use recursive calls.
-	For recursion you can stack calls:
-	"{% call call ... %}" -> "{% call ... %}"
-	""")
+class Cmd_Begin(Command):
+    def __call__(self, preprocessor: Preprocessor, args_string: str) -> str:
+        """The begin command, inserts token_begin
+        usage: begin [uint]
+        begin -> token_begin
+                begin 0 -> token_begin
+                begin <number> -> token_begin begin <number-1> token_end"""
+        args_string = args_string.strip()
+        level = 0
+        if args_string != "":
+            if args_string.isnumeric():
+                level = int(args_string)
+            else:
+                preprocessor.send_error(
+                    "invalid-argument", "invalid argument: usage begin [uint]"
+                )
+            if level < 0:
+                preprocessor.send_error(
+                    "invalid-argument", "invalid argument: usage begin [uint]"
+                )
+        if level == 0:
+            return preprocessor.token_begin
+        return (
+            preprocessor.token_begin
+            + " begin "
+            + str(level - 1)
+            + " "
+            + preprocessor.token_end
+        )
+
+    doc = """
+        Prints the current begin token (default "{%")
+
+        Usage: begin [<number>]
+        The optional number is used for recursion calls
+        begin     -> "{%"
+        begin 0   -> "{%"
+        begin <n> -> "{% begin <n-1> %}"
+        """
+
+
+class Cmd_End(Command):
+    def __call__(self, preprocessor: Preprocessor, args_string: str) -> str:
+        """The end command, inserts token_end
+        usage: end [uint]
+        end -> token_end
+                end 0 -> token_end
+                end <number> -> token_end end <number-1> token_end"""
+        args_string = args_string.strip()
+        level = 0
+        if args_string != "":
+            if args_string.isnumeric():
+                level = int(args_string)
+            else:
+                preprocessor.send_error(
+                    "invalid-argument", "invalid argument. Usage: end [uint]"
+                )
+            if level < 0:
+                preprocessor.send_error(
+                    "invalid-argument", "invalid argument. Usage: end [uint]"
+                )
+        if level == 0:
+            return preprocessor.token_end
+        else:
+            return (
+                preprocessor.token_begin
+                + " end "
+                + str(level - 1)
+                + " "
+                + preprocessor.token_end
+            )
+
+    doc = """
+        Prints the current end token (default "%}")
+
+        Usage: end [<number>]
+        The optional number is used for recursion calls
+        end     -> "%}"
+        end 0   -> "%}"
+        end <n> -> "{% end <n-1> %}"
+        """
+
+
+class Cmd_Call(Command):
+    def __call__(self, preprocessor: Preprocessor, args_string: str) -> str:
+        """The call command: used to print begin and end tokens
+        usage: {% call foo bar ... %} -> {% foo bar ... %}"""
+        args_string = args_string.strip()
+        if (
+            len(args_string) >= 2
+            and args_string[0] in preprocessor.string_delimiters
+            and args_string[-1] == args_string[0]
+        ):
+            args_string = args_string[1:-1]
+        return (
+            preprocessor.token_begin + " " + args_string + " " + preprocessor.token_end
+        )
+
+    doc = """
+        Prints a call to its arguments.
+
+        Ex: "{% call my_command my_args %}" -> "{% my_command my_args %}"
+        Useful in defs to use recursive calls.
+        For recursion you can stack calls:
+        "{% call call ... %}" -> "{% call ... %}"
+        """
+
 
 # ============================================================
 # label/paste
 # ============================================================
 
 
-def cmd_label(preprocessor: Preprocessor, arg_string: str) -> str:
-	"""the label command
-	usage: label label_name
-	  adds the label to preprocessor.labels[label_name]
-		which can be used by other commands/blocks
-	"""
-	lbl = arg_string.strip()
-	if lbl == "":
-		preprocessor.send_error("invalid-label", "empty label name")
-	preprocessor.labels.add_label(lbl, preprocessor.current_position.relative_begin)
-	return ""
-
-cmd_label.doc = ( # type: ignore
-	"""
-	Adds a label at the current position
-
-	Usage: label <label_name>
-	Where label_name must be a valid identifier.
-
-	Can be used in combination with the atlabel block
-	to place text at all occurrences of a label.
-	""")
-
-paste_parser = ArgumentParserNoExit(prog="cut", add_help=False)
-paste_parser.add_argument("--verbatim", "-v", action="store_true")
-paste_parser.add_argument("clipboard", nargs="?", default="")
-
-def cmd_paste(pre: Preprocessor, args: str) -> str:
-	"""the paste command
-	usage: paste [-v|--verbatim] [<clipboard_name>]"""
-	split = pre.split_args(args)
-	try:
-		arguments = paste_parser.parse_args(split)
-	except argparse.ArgumentError:
-		pre.send_error("invalid-argument",
-			"invalid argument.\nusage: paste [-v|--verbatim] [<clipboard_name>]"
-		)
-	clipboard = arguments.clipboard
-	if (
-		("clipboard" not in pre.command_vars)
-		or (clipboard not in pre.command_vars["clipboard"])
-	):
-		pre.send_warning("paste-undefined", "trying to paste undefined clipboard")
-		return ""
-	context, text = pre.command_vars["clipboard"][clipboard]
-	if not arguments.verbatim:
-		pre.context.new(context.file, context.position, context.description)
-		text = pre.parse(text)
-		pre.context.pop()
-	return text
-
-cmd_paste.doc = ( # type: ignore
-	"""
-	Pastes the contents of a clipboard (defined in a cut block)
-
-	Usage: paste [-v|--verbatim] [clipboard]
-	  if --verbatim is set, paste the text as is, without rendering it
-	  clipboard is a string identifying the clipboard (default "").
-	  it must match a previous cut block's clipboard argument
-	""")
-
-def cmd_date(_: Preprocessor, args: str) -> str:
-	"""the date command, prints the current date.
-	usage: date [format=YYYY-MM-DD]
-	  format specifies year with YYYY or YY, month with MM or M,
-	  day with DD or D, hour with hh or h, minutes with mm or m
-	  seconds with ss or s"""
-	args = args.strip()
-	if args == "":
-		args = "YYYY-MM-DD"
-	# we need to use a placeholder to avoid conflits
-	# in successive replaces
-	replacements = (
-		("YYYY", "\0001", "{year:04}"),
-		("YY", "\0002", "{year2:02}"),
-		("Y", "\0003", "{year}"),
-		("MM", "\0004", "{month:02}"),
-		("M", "\0005", "{month}"),
-		("DD", "\0006", "{day:02}"),
-		("D", "\0007", "{day}"),
-		("hh", "\0008", "{hour:02}"),
-		("h", "\0009", "{hour}"),
-		("mm", "\000a", "{minute:02}"),
-		("m", "\000b", "{minute}"),
-		("ss", "\000c", "{second:02}"),
-		("s", "\000d", "{second}"),
-	)
-	for val, placeholder, _ignore in replacements:
-		args = args.replace(val, placeholder)
-	for _ignore, placeholder, repl in replacements:
-		args = args.replace(placeholder, repl)
-	date = datetime.now()
-	return args.format(year = date.year, month = date.month, day = date.day,
-		hour = date.hour, minute = date.minute, second = date.second,
-		year2 = date.year % 100
-	)
-
-cmd_date.doc = ( # type: ignore
-	"""
-	Prints the current date.
-
-	Usage: date [format=YYYY-MM-DD]
-	  format specifies year with YYYY or YY, month with MM or M,
-	  day with DD or D, hour with hh or h, minutes with mm or m
-	  seconds with ss or s
-	""")
+class Cmd_Label(Command):
+    def __call__(self, preprocessor: Preprocessor, arg_string: str) -> str:
+        """the label command
+        usage: label label_name
+        adds the label to preprocessor.labels[label_name]
+                which can be used by other commands/blocks
+        """
+        lbl = arg_string.strip()
+        if lbl == "":
+            preprocessor.send_error("invalid-label", "empty label name")
+        preprocessor.labels.add_label(lbl, preprocessor.current_position.relative_begin)
+        return ""
+
+    doc = """
+        Adds a label at the current position
+
+        Usage: label <label_name>
+        Where label_name must be a valid identifier.
+
+        Can be used in combination with the atlabel block
+        to place text at all occurrences of a label.
+        """
+
+
+class Cmd_Paste(Command):
+    parser = ArgumentParserNoExit(prog="cut", add_help=False)
+    parser.add_argument("--verbatim", "-v", action="store_true")
+    parser.add_argument("clipboard", nargs="?", default="")
+
+    def __call__(self, pre: Preprocessor, args: str) -> str:
+        """the paste command
+        usage: paste [-v|--verbatim] [<clipboard_name>]"""
+        split = pre.split_args(args)
+        try:
+            arguments = self.parser.parse_args(split)
+        except argparse.ArgumentError:
+            pre.send_error(
+                "invalid-argument",
+                "invalid argument.\nusage: paste [-v|--verbatim] [<clipboard_name>]",
+            )
+        clipboard = arguments.clipboard
+        if ("clipboard" not in pre.command_vars) or (
+            clipboard not in pre.command_vars["clipboard"]
+        ):
+            pre.send_warning("paste-undefined", "trying to paste undefined clipboard")
+            return ""
+        context, text = pre.command_vars["clipboard"][clipboard]
+        if not arguments.verbatim:
+            pre.context.new(context.file, context.position, context.description)
+            text = pre.parse(text)
+            pre.context.pop()
+        return str(text)
+
+    doc = """
+        Pastes the contents of a clipboard (defined in a cut block)
+
+        Usage: paste [-v|--verbatim] [clipboard]
+        if --verbatim is set, paste the text as is, without rendering it
+        clipboard is a string identifying the clipboard (default "").
+        it must match a previous cut block's clipboard argument
+        """
+
+
+class Cmd_Date(Command):
+    def __call__(self, _: Preprocessor, args: str) -> str:
+        """the date command, prints the current date.
+        usage: date [format=YYYY-MM-DD]
+        format specifies year with YYYY or YY, month with MM or M,
+        day with DD or D, hour with hh or h, minutes with mm or m
+        seconds with ss or s"""
+        args = args.strip()
+        if args == "":
+            args = "YYYY-MM-DD"
+        # we need to use a placeholder to avoid conflits
+        # in successive replaces
+        replacements = (
+            ("YYYY", "\0001", "{year:04}"),
+            ("YY", "\0002", "{year2:02}"),
+            ("Y", "\0003", "{year}"),
+            ("MM", "\0004", "{month:02}"),
+            ("M", "\0005", "{month}"),
+            ("DD", "\0006", "{day:02}"),
+            ("D", "\0007", "{day}"),
+            ("hh", "\0008", "{hour:02}"),
+            ("h", "\0009", "{hour}"),
+            ("mm", "\000a", "{minute:02}"),
+            ("m", "\000b", "{minute}"),
+            ("ss", "\000c", "{second:02}"),
+            ("s", "\000d", "{second}"),
+        )
+        for val, placeholder, _ignore in replacements:
+            args = args.replace(val, placeholder)
+        for _ignore, placeholder, repl in replacements:
+            args = args.replace(placeholder, repl)
+        date = datetime.now()
+        return args.format(
+            year=date.year,
+            month=date.month,
+            day=date.day,
+            hour=date.hour,
+            minute=date.minute,
+            second=date.second,
+            year2=date.year % 100,
+        )
+
+    doc = """
+        Prints the current date.
+
+        Usage: date [format=YYYY-MM-DD]
+        format specifies year with YYYY or YY, month with MM or M,
+        day with DD or D, hour with hh or h, minutes with mm or m
+        seconds with ss or s
+        """
 
 
 # ============================================================
 # include
 # ============================================================
 
 
-include_parser = ArgumentParserNoExit(
-	prog="include", description="places the contents of the file at file_path",
-  add_help=False
-)
+class Cmd_Include(Command):
+    parser = ArgumentParserNoExit(
+        prog="include",
+        description="places the contents of the file at file_path",
+        add_help=False,
+    )
+
+    parser.add_argument("--verbatim", "-v", action="store_true")
+    parser.add_argument("--begin", "-b", nargs="?", default=None)
+    parser.add_argument("--end", "-e", nargs="?", default=None)
+    parser.add_argument("file_path")
+
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the include command
+        usage: include [-v|--verbatim] [-b|--begin <str>] [-e|--end <str>] file_path
+        places the contents of the file at file_path
+                --verbatim specifies that the file should not be parsed, it is parsed by default
+                --begin and --end can be used to set different preprocessor tokens
+                        for the file being included"""
+        split = preprocessor.split_args(args)
+        try:
+            arguments = self.parser.parse_args(split)
+        except argparse.ArgumentError:
+            preprocessor.send_error(
+                "invalid-argument",
+                "invalid argument.\nusage: include [-v|--verbatim] file_path",
+            )
+        filepath = arguments.file_path
+        if not isfile(filepath):
+            for include in preprocessor.include_path:
+                if isfile(join(include, filepath)):
+                    filepath = join(include, filepath)
+                    break
+            else:
+                preprocessor.send_error(
+                    "file-error", 'file not found "{}"'.format(arguments.file_path)
+                )
+        try:
+            with open(filepath, "r") as file:
+                contents = file.read()
+        except FileNotFoundError:
+            preprocessor.send_error(
+                "file-error", 'file not found "{}"'.format(arguments.file_path)
+            )
+        except PermissionError:
+            preprocessor.send_error(
+                "file-error",
+                'can\'t open file "{}", permission denied'.format(arguments.file_path),
+            )
+        except Exception:
+            preprocessor.send_error(
+                "file-error", 'can\'t open file "{}"'.format(arguments.file_path)
+            )
+        if not arguments.verbatim:
+            begin = preprocessor.token_begin
+            end = preprocessor.token_end
+            if arguments.begin is not None:
+                preprocessor.token_begin = arguments.begin
+            if arguments.end is not None:
+                preprocessor.token_end = arguments.end
+            preprocessor.include_path.append(dirname(abspath(filepath)))
+            preprocessor.context.new(
+                FileDescriptor(arguments.file_path, contents), 0, "in included file"
+            )
+            contents = preprocessor.parse(contents)
+            preprocessor.context.pop()
+            preprocessor.token_begin = begin
+            preprocessor.token_end = end
+        return contents
+
+    doc = """
+        Includes the content of another file.
+
+        Usage: include [--options] path
+        path can be absolute or relative to
+        any path in include_path: [current_working_dir, input_file_dir, output_file_dir]
+        paths can be added to include_path with the --include/-i/-I preprocessor option
+
+        Options:
+        -b --begin <string> specify the begin token ("{%")
+                            defaults to the same as current file
+        -e --end   <string> specify the end token ("%}")
+                            defaults to the same as current file
+        -v --verbatim       when present, includes files as is, without parsing.
+        """
+
+
+# ============================================================
+# Filesize
+# ============================================================
+
+
+class Cmd_FileSize(Command):
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the filesize command - prints the file size of its argument"""
+        file = args.strip()
+        if file == "":
+            preprocessor.send_error(
+                "missing-arguments",
+                "the filesize command takes one mandatory arguement 'filename'",
+            )
+        try:
+            return str(getsize(file))
+        except FileNotFoundError:
+            preprocessor.send_error("file-error", 'file not found "{}"'.format(file))
+        except PermissionError:
+            preprocessor.send_error(
+                "file-error", 'can\'t open file "{}", permission denied'.format(file)
+            )
+        except Exception:
+            preprocessor.send_error("file-error", 'can\'t open file "{}"'.format(file))
+        return ""
+
+    doc = """
+        Prints the size of its argument file (in bytes)
+
+        Fails if file doesn't exists/can't be read
+        """
+
+
+def pretty_size(value: int) -> str:
+    """Human readable file sizes: pretty_size(2654312) -> '2.6 Mio'"""
+    base = 1024
+    if value < base:
+        return f"{value} o"
+    size = float(value) / float(base)
+    for unit in ["Ki", "Mi", "Gi", "Ti", "Pi", "Ei", "Zi"]:
+        if abs(size) < base:
+            return f"{size:3.1f} {unit}o"
+        size /= float(base)
+    return f"{size:.1f} Yio"
+
+
+class Cmd_FilePrettySize(Command):
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the fileprettysize command - pretty prints the file size of its argument"""
+        file = args.strip()
+        if file == "":
+            preprocessor.send_error(
+                "missing-arguments",
+                "the fileprettysize command takes one mandatory arguement 'filename'",
+            )
+        try:
+            return pretty_size(getsize(file))
+        except FileNotFoundError:
+            preprocessor.send_error("file-error", 'file not found "{}"'.format(file))
+        except PermissionError:
+            preprocessor.send_error(
+                "file-error", 'can\'t open file "{}", permission denied'.format(file)
+            )
+        except Exception:
+            preprocessor.send_error("file-error", 'can\'t open file "{}"'.format(file))
+        return ""
+
+    doc = """
+        Pretty prints the size of its argument file (ex: 12.5 ko)
 
-include_parser.add_argument("--verbatim", "-v", action="store_true")
-include_parser.add_argument("--begin", "-b", nargs="?", default=None)
-include_parser.add_argument("--end", "-e", nargs="?", default=None)
-include_parser.add_argument("file_path")
-
-def cmd_include(preprocessor: Preprocessor, args: str) -> str:
-	"""the include command
-	usage: include [-v|--verbatim] [-b|--begin <str>] [-e|--end <str>] file_path
-	  places the contents of the file at file_path
-		--verbatim specifies that the file should not be parsed, it is parsed by default
-		--begin and --end can be used to set different preprocessor tokens
-			for the file being included"""
-	split = preprocessor.split_args(args)
-	try:
-		arguments = include_parser.parse_args(split)
-	except argparse.ArgumentError:
-		preprocessor.send_error("invalid-argument",
-			"invalid argument.\nusage: include [-v|--verbatim] file_path"
-		)
-	filepath = arguments.file_path
-	if not isfile(filepath):
-		for include in preprocessor.include_path:
-			if isfile(join(include, filepath)):
-				filepath = join(include, filepath)
-				break
-		else:
-			preprocessor.send_error("file-error",'file not found "{}"'.format(arguments.file_path))
-	try:
-		with open(filepath, "r") as file:
-			contents = file.read()
-	except FileNotFoundError:
-		preprocessor.send_error("file-error",'file not found "{}"'.format(arguments.file_path))
-	except PermissionError:
-		preprocessor.send_error("file-error",'can\'t open file "{}", permission denied'.format(arguments.file_path))
-	except Exception:
-		preprocessor.send_error("file-error",'can\'t open file "{}"'.format(arguments.file_path))
-	if not arguments.verbatim:
-		begin = preprocessor.token_begin
-		end = preprocessor.token_end
-		if arguments.begin is not None:
-			preprocessor.token_begin = arguments.begin
-		if arguments.end is not None:
-			preprocessor.token_end = arguments.end
-		preprocessor.include_path.append(dirname(abspath(filepath)))
-		preprocessor.context.new(FileDescriptor(arguments.file_path, contents), 0, "in included file")
-		contents = preprocessor.parse(contents)
-		preprocessor.context.pop()
-		preprocessor.token_begin = begin
-		preprocessor.token_end = end
-	return contents
-
-cmd_include.doc = ( # type: ignore
-	"""
-	Includes the content of another file.
-
-	Usage: include [--options] path
-	  path can be absolute or relative to
-	  any path in include_path: [current_working_dir, input_file_dir, output_file_dir]
-	  paths can be added to include_path with the --include/-i/-I preprocessor option
-
-	Options:
-	  -b --begin <string> specify the begin token ("{%")
-	                      defaults to the same as current file
-	  -e --end   <string> specify the end token ("%}")
-	                      defaults to the same as current file
-	  -v --verbatim       when present, includes files as is, without parsing.
-	""")
+        Fails if file doesn't exists/can't be read
+        """
```

## mlpproc/conditions.py

```diff
@@ -4,150 +4,161 @@
 from typing import List
 
 from .preprocessor import Preprocessor
 
 SINGLE_CHAR_OPERATORS = "()"
 DOUBLE_CHAR_OPERATORS = ["==", "!="]
 
-def condition_lexer(string : str) -> List[str]:
-	"""lexes the input string into a stream of tokens"""
-	lexemes : List[str] = []
-	in_string = False
-	current_lexeme = ""
-	str_len = len(string)
-	i = 0
-	while i < str_len:
-		char = string[i]
-		if in_string:
-			if char == '"':
-				in_string = False
-				lexemes.append(current_lexeme)
-				current_lexeme = ""
-			else:
-				current_lexeme += char
-		else:
-			# not in a string
-			if char in SINGLE_CHAR_OPERATORS:
-				if current_lexeme != "":
-					lexemes.append(current_lexeme)
-				lexemes.append(char)
-				current_lexeme = ""
-			elif i+1 < str_len and string[i:i+2] in DOUBLE_CHAR_OPERATORS:
-				if current_lexeme != "":
-					lexemes.append(current_lexeme)
-				lexemes.append(string[i:i+2])
-				current_lexeme = ""
-				i += 1
-			elif char == '"':
-				if current_lexeme != "":
-					lexemes.append(current_lexeme)
-				current_lexeme = ""
-				in_string = True
-			elif char.isspace():
-				if current_lexeme != "":
-					lexemes.append(current_lexeme)
-				current_lexeme = ""
-			else:
-				current_lexeme += char
-		i += 1
-	if current_lexeme:
-		lexemes.append(current_lexeme)
-	return lexemes
+
+def condition_lexer(string: str) -> List[str]:
+    """lexes the input string into a stream of tokens"""
+    lexemes: List[str] = []
+    in_string = False
+    current_lexeme = ""
+    str_len = len(string)
+    i = 0
+    while i < str_len:
+        char = string[i]
+        if in_string:
+            if char == '"':
+                in_string = False
+                lexemes.append(current_lexeme)
+                current_lexeme = ""
+            else:
+                current_lexeme += char
+        else:
+            # not in a string
+            if char in SINGLE_CHAR_OPERATORS:
+                if current_lexeme != "":
+                    lexemes.append(current_lexeme)
+                lexemes.append(char)
+                current_lexeme = ""
+            elif i + 1 < str_len and string[i : i + 2] in DOUBLE_CHAR_OPERATORS:
+                if current_lexeme != "":
+                    lexemes.append(current_lexeme)
+                lexemes.append(string[i : i + 2])
+                current_lexeme = ""
+                i += 1
+            elif char == '"':
+                if current_lexeme != "":
+                    lexemes.append(current_lexeme)
+                current_lexeme = ""
+                in_string = True
+            elif char.isspace():
+                if current_lexeme != "":
+                    lexemes.append(current_lexeme)
+                current_lexeme = ""
+            else:
+                current_lexeme += char
+        i += 1
+    if current_lexeme:
+        lexemes.append(current_lexeme)
+    return lexemes
+
 
 def find_matching_close_parenthese(tokens: List[str], start_index: int) -> int:
-	"""finds the ")" matching the opening parenthese "(" found at
-	tokens[start_index]. returns len(tokens) if none exists"""
-	j = start_index + 1
-	depth = 0
-	len_tok = len(tokens)
-	while j < len_tok:
-		if tokens[j] == "(":
-			depth += 1
-		if tokens[j] == ")":
-			depth -= 1
-			if depth == -1:
-				break
-		j += 1
-	return j
+    """finds the ")" matching the opening parenthese "(" found at
+    tokens[start_index]. returns len(tokens) if none exists"""
+    j = start_index + 1
+    depth = 0
+    len_tok = len(tokens)
+    while j < len_tok:
+        if tokens[j] == "(":
+            depth += 1
+        if tokens[j] == ")":
+            depth -= 1
+            if depth == -1:
+                break
+        j += 1
+    return j
+
 
 def condition_evaluator(preproc: Preprocessor, tokens: List[str]) -> bool:
-	"""evaluates a string of tokens into a boolean"""
-	i = 0
-	len_tok = len(tokens)
-	while i < len_tok:
-		tok = tokens[i]
-		if tok == "(":
-			j = find_matching_close_parenthese(tokens, i)
-			if j == len_tok:
-				preproc.send_error("invalid-condition",
-					"invalid condition syntax.\n"
-					"Unmatched \"(\". (missing closing parenthese?)"
-				)
-			if i == 0 and j == len_tok-1:
-				return condition_evaluator(preproc, tokens[1:-1])
-			i = j
-		elif tok == ")":
-			preproc.send_error("invalid-condition",
-				"invalid condition syntax.\n"
-				"Unmatched \")\". (missing openning parenthese?)"
-			)
-		elif tok == "and":
-			# uses python lazy evaluation
-			return condition_evaluator(preproc, tokens[:i])\
-				and condition_evaluator(preproc, tokens[i+1:])
-		elif tok == "or":
-			# uses python lazy evaluation
-			return condition_evaluator(preproc, tokens[:i])\
-				or condition_evaluator(preproc, tokens[i+1:])
-		elif tok == "not":
-			if i != 0:
-				preproc.send_error("invalid-condition",
-					'invalid condition syntax.\n'
-					'"not" must be preceeded by "and", "or" or "("\n'
-					'got "{} not"'.format(tokens[i-1])
-				)
-			return not condition_evaluator(preproc, tokens[1:])
-		i += 1
-	return simple_condition_evaluator(preproc, tokens)
+    """evaluates a string of tokens into a boolean"""
+    i = 0
+    len_tok = len(tokens)
+    while i < len_tok:
+        tok = tokens[i]
+        if tok == "(":
+            j = find_matching_close_parenthese(tokens, i)
+            if j == len_tok:
+                preproc.send_error(
+                    "invalid-condition",
+                    "invalid condition syntax.\n"
+                    'Unmatched "(". (missing closing parenthese?)',
+                )
+            if i == 0 and j == len_tok - 1:
+                return condition_evaluator(preproc, tokens[1:-1])
+            i = j
+        elif tok == ")":
+            preproc.send_error(
+                "invalid-condition",
+                "invalid condition syntax.\n"
+                'Unmatched ")". (missing openning parenthese?)',
+            )
+        elif tok == "and":
+            # uses python lazy evaluation
+            return condition_evaluator(preproc, tokens[:i]) and condition_evaluator(
+                preproc, tokens[i + 1 :]
+            )
+        elif tok == "or":
+            # uses python lazy evaluation
+            return condition_evaluator(preproc, tokens[:i]) or condition_evaluator(
+                preproc, tokens[i + 1 :]
+            )
+        elif tok == "not":
+            if i != 0:
+                preproc.send_error(
+                    "invalid-condition",
+                    "invalid condition syntax.\n"
+                    '"not" must be preceeded by "and", "or" or "("\n'
+                    'got "{} not"'.format(tokens[i - 1]),
+                )
+            return not condition_evaluator(preproc, tokens[1:])
+        i += 1
+    return simple_condition_evaluator(preproc, tokens)
+
 
 def simple_condition_evaluator(preproc: Preprocessor, tokens: List[str]) -> bool:
-	"""evaluates a string of tokens into a boolean,
-	assumes the string of tokens doesn't contain "and", "or" and "not"
-	"""
-	len_tok = len(tokens)
-	if len_tok == 1:
-		return not(tokens[0] in ["false", "0", ""])
-	if len_tok == 2:
-		if tokens[0] == "def":
-			return tokens[1] in preproc.commands or tokens[1] in preproc.blocks
-		if tokens[0] == "ndef":
-			return not (tokens[1] in preproc.commands or tokens[1] in preproc.blocks)
-	if len_tok == 3:
-		if tokens[1] == "==":
-			return tokens[0] == tokens[2]
-		if tokens[1] == "!=":
-			return tokens[0] != tokens[2]
-	preproc.send_error("invalid-condition",
-		"invalid condition syntax.\n"
-		"simple conditions are: \n"
-		"  | true | false | 1 | 0 | <string>\n"
-		"  | def <identifier> | ndef <identifier>\n"
-		"  | <str> == <str> | <str> != <str>"
-	)
-	return False
+    """evaluates a string of tokens into a boolean,
+    assumes the string of tokens doesn't contain "and", "or" and "not"
+    """
+    len_tok = len(tokens)
+    if len_tok == 1:
+        return not (tokens[0] in ["false", "0", ""])
+    if len_tok == 2:
+        if tokens[0] == "def":
+            return tokens[1] in preproc.commands or tokens[1] in preproc.blocks
+        if tokens[0] == "ndef":
+            return not (tokens[1] in preproc.commands or tokens[1] in preproc.blocks)
+    if len_tok == 3:
+        if tokens[1] == "==":
+            return tokens[0] == tokens[2]
+        if tokens[1] == "!=":
+            return tokens[0] != tokens[2]
+    preproc.send_error(
+        "invalid-condition",
+        "invalid condition syntax.\n"
+        "simple conditions are: \n"
+        "  | true | false | 1 | 0 | <string>\n"
+        "  | def <identifier> | ndef <identifier>\n"
+        "  | <str> == <str> | <str> != <str>",
+    )
+    return False
+
 
 def condition_eval(preproc: Preprocessor, string: str) -> bool:
-	"""evaluates a condition.
-	String must follow the condition syntax:
+    """evaluates a condition.
+    String must follow the condition syntax:
 
-	simple_condition =
-		| true | false | 1 | 0 | <string>
-		| def <identifier> | ndef <identifier>
-		| <str> == <str> | <str> != <str>
-
-	condition =
-		| <simple_condition> | not <simple_condition>
-		| <condition> and <condition>
-		| <condition> or <condition>
-		| (<condition>)"""
-	lexemes = condition_lexer(string)
-	return condition_evaluator(preproc, lexemes)
+    simple_condition =
+            | true | false | 1 | 0 | <string>
+            | def <identifier> | ndef <identifier>
+            | <str> == <str> | <str> != <str>
+
+    condition =
+            | <simple_condition> | not <simple_condition>
+            | <condition> and <condition>
+            | <condition> or <condition>
+            | (<condition>)"""
+    lexemes = condition_lexer(string)
+    return condition_evaluator(preproc, lexemes)
```

## mlpproc/context.py

```diff
@@ -1,188 +1,196 @@
 """This module is used to traceback error to file positions
 
 It contains:
 
 - class FileDescriptor
-	contains info about a file (name, contents and linebreaks)
+    contains info about a file (name, contents and linebreaks)
 
 - class ContextElement
-	stores a current context with
-	- a FileDescriptor (file to point back to when reporting errors)
-	- a position
-	- a description
-	- a list of dilatations that account for insertion/deletions
+    stores a current context with
+    - a FileDescriptor (file to point back to when reporting errors)
+    - a position
+    - a description
+    - a list of dilatations that account for insertion/deletions
 
 - class ContextStack:
-	a stack of ContextElements
-	add elements on top with .new() or .update()
-	remove them with .pop()
-	.trace() shows a trace leading to the topmost context
+    a stack of ContextElements
+    add elements on top with .new() or .update()
+    remove them with .pop()
+    .trace() shows a trace leading to the topmost context
 """
 
 import re
 from typing import List, Optional, Tuple
 
 
 class FileDescriptor:
-	"""describes a file,
-	contains:
-	- file name
-	- file initial contents
-	- line breaks"""
-
-	filename: str
-	contents: str
-	_line_breaks: List[int]
-
-	def __init__(self: "FileDescriptor", filename: str, contents: str) -> None:
-		"""initialises the FileDescriptor element and computes linebreaks"""
-		self.filename = filename
-		self.contents = contents
-		self._line_breaks = self.line_breaks_from_str(contents)
-
-	@staticmethod
-	def line_breaks_from_str(string: str) -> List[int]:
-		"""Generates a list of line break indices from a given string
-		i.e. return L containing all index i such that
-		string[i] == "\\n"
-		"""
-		return [n.start() for n in re.finditer(re.escape("\n"), string)]
-
-	def line_number(self: "FileDescriptor", pos: int) -> Tuple[int, int]:
-		"""Returns a tuple (line number, char number on line)
-		from an absolute position"""
-		line_nb = 1
-		closest_line_end = 0
-		for line_end in self._line_breaks:
-			if line_end <= pos:
-				line_nb += 1
-				if pos - line_end < pos - closest_line_end:
-					closest_line_end = line_end
-		return line_nb, pos - closest_line_end
+    """describes a file,
+    contains:
+    - file name
+    - file initial contents
+    - line breaks"""
+
+    filename: str
+    contents: str
+    _line_breaks: List[int]
+
+    def __init__(self: "FileDescriptor", filename: str, contents: str) -> None:
+        """initialises the FileDescriptor element and computes linebreaks"""
+        self.filename = filename
+        self.contents = contents
+        self._line_breaks = self.line_breaks_from_str(contents)
+
+    @staticmethod
+    def line_breaks_from_str(string: str) -> List[int]:
+        """Generates a list of line break indices from a given string
+        i.e. return L containing all index i such that
+        string[i] == "\\n"
+        """
+        return [n.start() for n in re.finditer(re.escape("\n"), string)]
+
+    def line_number(self: "FileDescriptor", pos: int) -> Tuple[int, int]:
+        """Returns a tuple (line number, char number on line)
+        from an absolute position"""
+        line_nb = 1
+        closest_line_end = 0
+        for line_end in self._line_breaks:
+            if line_end <= pos:
+                line_nb += 1
+                if pos - line_end < pos - closest_line_end:
+                    closest_line_end = line_end
+        return line_nb, pos - closest_line_end
 
 
 class ContextElement:
-	"""Context for error tracing
-	stores:
-	- file names
-	- line breaks (to recover line number)
-	- dilatations (how are indexes shifted by insertions/deletions)
-	It is used to recover the initial position for error traceback"""
-
-	file: FileDescriptor
-	description: str
-	position: int
-	is_new: bool
-	_dilatations: List[Tuple[int, int]]
-
-	def __init__(
-		self: "ContextElement", file: FileDescriptor, desc: str, pos: int, is_new: bool = True
-	) -> None:
-		"""initializes a new ContextElement"""
-		self.file = file
-		self.description = desc
-		self.position = pos
-		self.is_new = is_new
-		self._dilatations = []
-
-	def true_position(self: "ContextElement", position: int) -> int:
-		"""Returns the true position, taking dilatations
-		into account"""
-		for pos, value in self._dilatations[::-1]:
-			if pos <= position:
-				position -= value
-		return position
-
-	def add_dilatation(self: "ContextElement", pos: int, value: int) -> None:
-		"""Adds a dilatation, i.e. indicates that
-		position after pos are increased/decreased by value
-		Ex when changing "bar foo bar" to "bar newfoo bar"
-		  add a dilatation (pos = 4, value = len("newfoo") - len("foo"))
-		"""
-		if value != 0:
-			self._dilatations.append((pos, value))
-
-	def copy(self: "ContextElement", position: int, desc: Optional[str] = None) -> "ContextElement":
-		"""returns a copy of self"""
-		if desc is None:
-			desc = self.description
-		copy = ContextElement(self.file, desc, position, False)
-		for pos, value in self._dilatations:
-			copy.add_dilatation(pos, value)
-		return copy
+    """Context for error tracing
+    stores:
+    - file names
+    - line breaks (to recover line number)
+    - dilatations (how are indexes shifted by insertions/deletions)
+    It is used to recover the initial position for error traceback"""
+
+    file: FileDescriptor
+    description: str
+    position: int
+    is_new: bool
+    _dilatations: List[Tuple[int, int]]
+
+    def __init__(
+        self: "ContextElement",
+        file: FileDescriptor,
+        desc: str,
+        pos: int,
+        is_new: bool = True,
+    ) -> None:
+        """initializes a new ContextElement"""
+        self.file = file
+        self.description = desc
+        self.position = pos
+        self.is_new = is_new
+        self._dilatations = []
+
+    def true_position(self: "ContextElement", position: int) -> int:
+        """Returns the true position, taking dilatations
+        into account"""
+        for pos, value in self._dilatations[::-1]:
+            if pos <= position:
+                position -= value
+        return position
+
+    def add_dilatation(self: "ContextElement", pos: int, value: int) -> None:
+        """Adds a dilatation, i.e. indicates that
+        position after pos are increased/decreased by value
+        Ex when changing "bar foo bar" to "bar newfoo bar"
+          add a dilatation (pos = 4, value = len("newfoo") - len("foo"))
+        """
+        if value != 0:
+            self._dilatations.append((pos, value))
+
+    def copy(
+        self: "ContextElement", position: int, desc: Optional[str] = None
+    ) -> "ContextElement":
+        """returns a copy of self"""
+        if desc is None:
+            desc = self.description
+        copy = ContextElement(self.file, desc, position, False)
+        for pos, value in self._dilatations:
+            copy.add_dilatation(pos, value)
+        return copy
 
 
 class EmptyContextStack(ValueError):
-	"""Exception raised when context stack
-	is empty"""
+    """Exception raised when context stack
+    is empty"""
 
 
 class ContextStack:
-	"""Class used to store context information to print in traceback"""
-	_stack: List[ContextElement]
+    """Class used to store context information to print in traceback"""
 
-	def __init__(self: "ContextStack", stack: List[ContextElement] = []) -> None:
-		"""initializes a new context stack"""
-		self._stack = stack
-
-	@property
-	def top(self: "ContextStack") -> ContextElement:
-		"""returns the top element
-		raises EmptyContextStack if empty"""
-		if not self.is_empty():
-			return self._stack[-1]
-		raise EmptyContextStack
-
-	def new(self: "ContextStack", file: FileDescriptor, pos: int, desc: str = "") -> None:
-		"""adds context relative to a new file on top of the stack
-		pos should be the position relative to the start of the file
-		desc is an optional description string (ex "in command my_command")"""
-		self._stack.append(ContextElement(file, desc, pos))
-
-	def update(self: "ContextStack", pos: int, desc: Optional[str] = None) -> None:
-		"""adds a new context element based on the previous one on top of the stack
-		pos: position relative to start of file
-		desc: optional string description"""
-		self._stack.append(self.top.copy(pos, desc))
-
-	def pop(self: "ContextStack") -> None:
-		"""removes the topmost Context from the stack"""
-		if self._stack:
-			del self._stack[-1]
-		else:
-			raise EmptyContextStack
-
-	def add_dilatation(self: "ContextStack", pos: int, value: int) -> None:
-		"""Adds a dilatation to topmost context.
-		It indicates that positions after pos are increased/decreased by value
-		Ex when changing "bar foo bar" to "bar newfoo bar"
-		  add a dilatation (pos = 4, value = len("newfoo") - len("foo"))"""
-		self.top.add_dilatation(pos, value)
-
-	def trace(self: "ContextStack") -> str:
-		"""Returns a string trace for error solving.
-		It is in the format:
-		"path/to/file:line:char: desc
-		path/to/topmost/file:line:char: topmost desc
-		path/to/topmost/file:line:char:"
-		"""
-		trace = ""
-		stack_size = len(self._stack)
-		for i, elem in enumerate(self._stack):
-			if i + 1 == stack_size or self._stack[i+1].is_new:
-				line, char = elem.file.line_number(elem.true_position(elem.position))
-				trace += "{}:{}:{}: {}\n".format(
-					elem.file.filename, line, char, elem.description
-				)
-		if self._stack:
-			elem = self.top
-			line, char = elem.file.line_number(elem.true_position(elem.position))
-			trace += "{}:{}:{}:".format(elem.file.filename, line, char)
-		else:
-			trace += "EMPTY STACK:"
-		return trace
-
-
-	def is_empty(self: "ContextStack") -> bool:
-		"""returns True if stack is empty, False otherwise"""
-		return self._stack == []
+    _stack: List[ContextElement]
+
+    def __init__(self: "ContextStack", stack: List[ContextElement] = []) -> None:
+        """initializes a new context stack"""
+        self._stack = stack
+
+    @property
+    def top(self: "ContextStack") -> ContextElement:
+        """returns the top element
+        raises EmptyContextStack if empty"""
+        if not self.is_empty():
+            return self._stack[-1]
+        raise EmptyContextStack
+
+    def new(
+        self: "ContextStack", file: FileDescriptor, pos: int, desc: str = ""
+    ) -> None:
+        """adds context relative to a new file on top of the stack
+        pos should be the position relative to the start of the file
+        desc is an optional description string (ex "in command my_command")"""
+        self._stack.append(ContextElement(file, desc, pos))
+
+    def update(self: "ContextStack", pos: int, desc: Optional[str] = None) -> None:
+        """adds a new context element based on the previous one on top of the stack
+        pos: position relative to start of file
+        desc: optional string description"""
+        self._stack.append(self.top.copy(pos, desc))
+
+    def pop(self: "ContextStack") -> None:
+        """removes the topmost Context from the stack"""
+        if self._stack:
+            del self._stack[-1]
+        else:
+            raise EmptyContextStack
+
+    def add_dilatation(self: "ContextStack", pos: int, value: int) -> None:
+        """Adds a dilatation to topmost context.
+        It indicates that positions after pos are increased/decreased by value
+        Ex when changing "bar foo bar" to "bar newfoo bar"
+          add a dilatation (pos = 4, value = len("newfoo") - len("foo"))"""
+        self.top.add_dilatation(pos, value)
+
+    def trace(self: "ContextStack") -> str:
+        """Returns a string trace for error solving.
+        It is in the format:
+        "path/to/file:line:char: desc
+        path/to/topmost/file:line:char: topmost desc
+        path/to/topmost/file:line:char:"
+        """
+        trace = ""
+        stack_size = len(self._stack)
+        for i, elem in enumerate(self._stack):
+            if i + 1 == stack_size or self._stack[i + 1].is_new:
+                line, char = elem.file.line_number(elem.true_position(elem.position))
+                trace += "{}:{}:{}: {}\n".format(
+                    elem.file.filename, line, char, elem.description
+                )
+        if self._stack:
+            elem = self.top
+            line, char = elem.file.line_number(elem.true_position(elem.position))
+            trace += "{}:{}:{}:".format(elem.file.filename, line, char)
+        else:
+            trace += "EMPTY STACK:"
+        return trace
+
+    def is_empty(self: "ContextStack") -> bool:
+        """returns True if stack is empty, False otherwise"""
+        return self._stack == []
```

## mlpproc/defaults.py

```diff
@@ -1,54 +1,98 @@
 """
 This module add all default commands/blocks/final_actions to
 the Preprocessor class variables.
 """
 
-from .blocks import *
-from .commands import *
-from .final_actions import *
+from .blocks import (
+    Blck_Atlabel,
+    Blck_Block,
+    Blck_Comment,
+    Blck_Cut,
+    Blck_For,
+    Blck_If,
+    Blck_Repeat,
+    Blck_Verbatim,
+    Blck_Void,
+    Fnl_AtLabel,
+)
+from .commands import (
+    Cmd_Begin,
+    Cmd_Call,
+    Cmd_Date,
+    Cmd_Def,
+    Cmd_Deflist,
+    Cmd_End,
+    Cmd_Error,
+    Cmd_Filename,
+    Cmd_FilePrettySize,
+    Cmd_FileSize,
+    Cmd_Include,
+    Cmd_Label,
+    Cmd_Line,
+    Cmd_Paste,
+    Cmd_Undef,
+    Cmd_Version,
+    Cmd_Warning,
+)
+from .final_actions import (
+    Cmd_Capitalize,
+    Cmd_FixFirstLine,
+    Cmd_FixLastLine,
+    Cmd_Lower,
+    Cmd_Replace,
+    Cmd_Strip,
+    Cmd_StripEmptyLines,
+    Cmd_StripLeadingWhitespace,
+    Cmd_StripTrailingWhitespace,
+    Cmd_Upper,
+)
 from .preprocessor import Preprocessor
 
 # default commands
 
-Preprocessor.commands["def"] = cmd_def
-Preprocessor.commands["undef"] = cmd_undef
-Preprocessor.commands["deflist"] = cmd_deflist
-Preprocessor.commands["begin"] = cmd_begin
-Preprocessor.commands["end"] = cmd_end
-Preprocessor.commands["call"] = cmd_call
-Preprocessor.commands["label"] = cmd_label
-Preprocessor.commands["date"] = cmd_date
-Preprocessor.commands["include"] = cmd_include
-Preprocessor.commands["error"] = cmd_error
-Preprocessor.commands["warning"] = cmd_warning
-Preprocessor.commands["version"] = cmd_version
-Preprocessor.commands["filename"] = cmd_filename
-Preprocessor.commands["line"] = cmd_line
-Preprocessor.commands["paste"] = cmd_paste
-
-Preprocessor.commands["strip_empty_lines"] = final_action_command(fnl_strip_empty_lines)
-Preprocessor.commands["strip_leading_whitespace"] = final_action_command(fnl_strip_leading_whitespace)
-Preprocessor.commands["strip_trailing_whitespace"] = final_action_command(fnl_strip_trailing_whitespace)
-Preprocessor.commands["fix_last_line"] = final_action_command(fnl_fix_last_line)
-Preprocessor.commands["fix_first_line"] = final_action_command(fnl_fix_first_line)
-Preprocessor.commands["strip"] = cmd_strip
-Preprocessor.commands["replace"] = cmd_replace
-Preprocessor.commands["upper"] = cmd_upper
-Preprocessor.commands["lower"] = cmd_lower
-Preprocessor.commands["capitalize"] = cmd_capitalize
+Preprocessor.commands["def"] = Cmd_Def()
+Preprocessor.commands["undef"] = Cmd_Undef()
+Preprocessor.commands["deflist"] = Cmd_Deflist()
+Preprocessor.commands["begin"] = Cmd_Begin()
+Preprocessor.commands["end"] = Cmd_End()
+Preprocessor.commands["call"] = Cmd_Call()
+Preprocessor.commands["label"] = Cmd_Label()
+Preprocessor.commands["date"] = Cmd_Date()
+Preprocessor.commands["include"] = Cmd_Include()
+Preprocessor.commands["error"] = Cmd_Error()
+Preprocessor.commands["warning"] = Cmd_Warning()
+Preprocessor.commands["version"] = Cmd_Version()
+Preprocessor.commands["filename"] = Cmd_Filename()
+Preprocessor.commands["line"] = Cmd_Line()
+Preprocessor.commands["paste"] = Cmd_Paste()
+Preprocessor.commands["filesize"] = Cmd_FileSize()
+Preprocessor.commands["fileprettysize"] = Cmd_FilePrettySize()
+
+Preprocessor.commands["strip_empty_lines"] = Cmd_StripEmptyLines()
+Preprocessor.commands["strip_leading_whitespace"] = Cmd_StripLeadingWhitespace()
+Preprocessor.commands["strip_trailing_whitespace"] = Cmd_StripTrailingWhitespace()
+Preprocessor.commands["fix_last_line"] = Cmd_FixLastLine()
+Preprocessor.commands["fix_first_line"] = Cmd_FixFirstLine()
+Preprocessor.commands["strip"] = Cmd_Strip()
+Preprocessor.commands["replace"] = Cmd_Replace()
+Preprocessor.commands["upper"] = Cmd_Upper()
+Preprocessor.commands["lower"] = Cmd_Lower()
+Preprocessor.commands["capitalize"] = Cmd_Capitalize()
 
 # default post action
 
-Preprocessor.final_actions.append(fnl_atlabel)
+Preprocessor.final_actions.append(Fnl_AtLabel())
 
 # default blocks
 
-Preprocessor.blocks["void"] = blck_void
-Preprocessor.blocks["comment"] = blck_comment
-Preprocessor.blocks["block"] = blck_block
-Preprocessor.blocks["verbatim"] = blck_verbatim
-Preprocessor.blocks["repeat"] = blck_repeat
-Preprocessor.blocks["atlabel"] = blck_atlabel
-Preprocessor.blocks["for"] = blck_for
-Preprocessor.blocks["cut"] = blck_cut
-Preprocessor.blocks["if"] = blck_if
+Preprocessor.blocks["void"] = Blck_Void()
+Preprocessor.blocks["comment"] = Blck_Comment()
+Preprocessor.blocks["block"] = Blck_Block()
+Preprocessor.blocks["verbatim"] = Blck_Verbatim()
+Preprocessor.blocks["repeat"] = Blck_Repeat()
+Preprocessor.blocks["atlabel"] = Blck_Atlabel()
+Preprocessor.blocks["for"] = Blck_For()
+Preprocessor.blocks["cut"] = Blck_Cut()
+Preprocessor.blocks["if"] = Blck_If()
+
+__all__ = ("Preprocessor", "Cmd_Def")
```

## mlpproc/defs.py

```diff
@@ -6,193 +6,200 @@
 - class Position to represent position to command
 - enum WarningMode to configure the Preprocessor
 - function trim to pretty-print docstrings
 - function process_string to process read string ("\\n" into newline)
 - functions is_integer or to_integer to get ints from strings
 - function get_identifier_name to find the first identifier in a string
 """
+
 import argparse
 import enum
 import re
-from typing import Tuple
+from typing import NoReturn, Tuple
 
 PREPROCESSOR_NAME = "mlpp"
-PREPROCESSOR_VERSION = "1.0.2"
+PREPROCESSOR_VERSION = "1.0.3"
 
-REGEX_IDENTIFIER:       str = "[_a-zA-Z][_a-zA-Z0-9]*"
+REGEX_IDENTIFIER: str = "[_a-zA-Z][_a-zA-Z0-9]*"
 REGEX_IDENTIFIER_WRAPPED: str = "(^|(?<=([^_a-zA-Z0-9]))){}((?=([^_a-zA-Z0-9]))|$)"
-REGEX_IDENTIFIER_END:   str = "$|[^_a-zA-Z0-9]"
+REGEX_IDENTIFIER_END: str = "$|[^_a-zA-Z0-9]"
 REGEX_IDENTIFIER_BEGIN: str = "^|[^_a-zA-Z]"
 REGEX_STRING: str = '""|".*?[^\\\\]"'
 REGEX_INTEGER: str = r"-?\ *[0-9]+(?:[_0-9]*[0-9])?"
 
 
 class Position:
-	"""represents a position to a command
-	#1{% #2cmd#3 args#4 %}#5...#6{% endcmd %}#7
-	- #1 - begin
-	- #2 - cmd_begin
-	- #3 - cmd_argbegin
-	- #4 - cmd_end
-	- #5 - end
-	#6 and #7 values are meaningless if not a block
-	- #6 - endblock_begin
-	- #7 - endblock_end
-	these values are relative to the start of the source file
-	being scanned. For values relative to the start of the string
-	use relative_begin, relative_end...
-
-	offset represents the offset between current string and source"""
-	offset: int = 0
-
-	begin:          int = 0
-	end:            int = 0
-	cmd_begin:      int = 0
-	cmd_end:        int = 0
-	cmd_argbegin:   int = 0
-	endblock_begin: int = 0
-	endblock_end:   int = 0
-
-	def to_relative(self: "Position", value: int) -> int:
-		"""transform a value relative to source into one relative to current string"""
-		return value - self.offset
-
-	def from_relative(self: "Position", value: int) -> int:
-		"""transform a value relative to current string into one relative to source"""
-		return value + self.offset
-
-	relative_begin: property = property(
-		lambda self: self.to_relative(self.begin),
-		lambda self, value: setattr(self, "begin", self.from_relative(value)),
-		doc="same as begin, but relative to start of current parsed string\n"
-		    "(begin is relative to start of file)"
-	)
-	relative_end: property = property(
-		lambda self: self.to_relative(self.end),
-		lambda self, value: setattr(self, "end", self.from_relative(value)),
-		doc="same as end, but relative to start of current parsed string\n"
-		    "(end is relative to start of file)"
-	)
-	relative_cmd_begin: property = property(
-		lambda self: self.to_relative(self.cmd_begin),
-		lambda self, value: setattr(self, "cmd_begin", self.from_relative(value)),
-		doc="same as cmd_begin, but relative to start of current parsed string\n"
-		    "(cmd_begin is relative to start of file)"
-	)
-	relative_cmd_end: property = property(
-		lambda self: self.to_relative(self.cmd_end),
-		lambda self, value: setattr(self, "cmd_end", self.from_relative(value)),
-		doc="same as cmd_end, but relative to start of current parsed string\n"
-		    "(cmd_end is relative to start of file)"
-	)
-	relative_cmd_argbegin: property = property(
-		lambda self: self.to_relative(self.cmd_argbegin),
-		lambda self, value: setattr(self, "cmd_argbegin", self.from_relative(value)),
-		doc="same as cmd_argbegin, but relative to start of current parsed string\n"
-		    "(cmd_argbegin is relative to start of file)"
-	)
-	relative_endblock_begin: property = property(
-		lambda self: self.to_relative(self.endblock_begin),
-		lambda self, value: setattr(self, "endblock_begin", self.from_relative(value)),
-		doc="same as endblock_begin, but relative to start of current parsed string\n"
-		    "(endblock_begin is relative to start of file)"
-	)
-	relative_endblock_end: property = property(
-		lambda self: self.to_relative(self.endblock_end),
-		lambda self, value: setattr(self, "endblock_end", self.from_relative(value)),
-		doc="same as endblock_end, but relative to start of current parsed string\n"
-		    "(endblock_end is relative to start of file)"
-	)
-
-	def copy(self:"Position") -> "Position":
-		"""creates an independent copy"""
-		new = Position()
-		new.offset = self.offset
-		new.begin = self.begin
-		new.end = self.end
-		new.cmd_begin = self.cmd_begin
-		new.cmd_end = self.cmd_end
-		new.cmd_argbegin = self.cmd_argbegin
-		new.endblock_begin = self.endblock_begin
-		new.endblock_end = self.endblock_end
-		return new
+    """represents a position to a command
+    #1{% #2cmd#3 args#4 %}#5...#6{% endcmd %}#7
+    - #1 - begin
+    - #2 - cmd_begin
+    - #3 - cmd_argbegin
+    - #4 - cmd_end
+    - #5 - end
+    #6 and #7 values are meaningless if not a block
+    - #6 - endblock_begin
+    - #7 - endblock_end
+    these values are relative to the start of the source file
+    being scanned. For values relative to the start of the string
+    use relative_begin, relative_end...
+
+    offset represents the offset between current string and source"""
+
+    offset: int = 0
+
+    begin: int = 0
+    end: int = 0
+    cmd_begin: int = 0
+    cmd_end: int = 0
+    cmd_argbegin: int = 0
+    endblock_begin: int = 0
+    endblock_end: int = 0
+
+    def to_relative(self: "Position", value: int) -> int:
+        """transform a value relative to source into one relative to current string"""
+        return value - self.offset
+
+    def from_relative(self: "Position", value: int) -> int:
+        """transform a value relative to current string into one relative to source"""
+        return value + self.offset
+
+    relative_begin: property = property(
+        lambda self: self.to_relative(self.begin),
+        lambda self, value: setattr(self, "begin", self.from_relative(value)),
+        doc="same as begin, but relative to start of current parsed string\n"
+        "(begin is relative to start of file)",
+    )
+    relative_end: property = property(
+        lambda self: self.to_relative(self.end),
+        lambda self, value: setattr(self, "end", self.from_relative(value)),
+        doc="same as end, but relative to start of current parsed string\n"
+        "(end is relative to start of file)",
+    )
+    relative_cmd_begin: property = property(
+        lambda self: self.to_relative(self.cmd_begin),
+        lambda self, value: setattr(self, "cmd_begin", self.from_relative(value)),
+        doc="same as cmd_begin, but relative to start of current parsed string\n"
+        "(cmd_begin is relative to start of file)",
+    )
+    relative_cmd_end: property = property(
+        lambda self: self.to_relative(self.cmd_end),
+        lambda self, value: setattr(self, "cmd_end", self.from_relative(value)),
+        doc="same as cmd_end, but relative to start of current parsed string\n"
+        "(cmd_end is relative to start of file)",
+    )
+    relative_cmd_argbegin: property = property(
+        lambda self: self.to_relative(self.cmd_argbegin),
+        lambda self, value: setattr(self, "cmd_argbegin", self.from_relative(value)),
+        doc="same as cmd_argbegin, but relative to start of current parsed string\n"
+        "(cmd_argbegin is relative to start of file)",
+    )
+    relative_endblock_begin: property = property(
+        lambda self: self.to_relative(self.endblock_begin),
+        lambda self, value: setattr(self, "endblock_begin", self.from_relative(value)),
+        doc="same as endblock_begin, but relative to start of current parsed string\n"
+        "(endblock_begin is relative to start of file)",
+    )
+    relative_endblock_end: property = property(
+        lambda self: self.to_relative(self.endblock_end),
+        lambda self, value: setattr(self, "endblock_end", self.from_relative(value)),
+        doc="same as endblock_end, but relative to start of current parsed string\n"
+        "(endblock_end is relative to start of file)",
+    )
+
+    def copy(self: "Position") -> "Position":
+        """creates an independent copy"""
+        new = Position()
+        new.offset = self.offset
+        new.begin = self.begin
+        new.end = self.end
+        new.cmd_begin = self.cmd_begin
+        new.cmd_end = self.cmd_end
+        new.cmd_argbegin = self.cmd_argbegin
+        new.endblock_begin = self.endblock_begin
+        new.endblock_end = self.endblock_end
+        return new
 
 
 @enum.unique
 class TokenMatch(enum.IntEnum):
-	"""Used to represent Open/Closed tokens"""
-	OPEN = 0
-	CLOSE = 1
+    """Used to represent Open/Closed tokens"""
+
+    OPEN = 0
+    CLOSE = 1
 
 
 def process_string(string: str) -> str:
-	"""Change escape sequences to the chars they match
-	ex: process_string("\\\\n") -> "\\n\""""
-	replacements = [
-		("\\\\", "\x00"),
-		("\\n", "\n"),
-		("\\t", "\t"),
-		("\\r", "\r"),
-		('\\"', '\"'),
-		("\\'", "'"),
-		("\x00", "\\"),
-	]
-	for search, replace in replacements:
-		string = string.replace(search, replace)
-	return string
+    """Change escape sequences to the chars they match
+    ex: process_string("\\\\n") -> "\\n\" """
+    replacements = [
+        ("\\\\", "\x00"),
+        ("\\n", "\n"),
+        ("\\t", "\t"),
+        ("\\r", "\r"),
+        ('\\"', '"'),
+        ("\\'", "'"),
+        ("\x00", "\\"),
+    ]
+    for search, replace in replacements:
+        string = string.replace(search, replace)
+    return string
 
 
 class ArgumentParserNoExit(argparse.ArgumentParser):
-	"""subclass of argparse.ArgumentParser which
-	raises an error rather than exiting when parsing fails"""
-	def error(self, message):
-		raise argparse.ArgumentError(None, message)
+    """subclass of argparse.ArgumentParser which
+    raises an error rather than exiting when parsing fails"""
+
+    def error(self, message: str) -> NoReturn:
+        raise argparse.ArgumentError(None, message)
 
 
 def get_identifier_name(string: str) -> Tuple[str, str, int]:
-	"""finds the first identifier in string:
-	Returns:
-		tuple str, str, int - identifier, rest_of_string, start_of_rest_of_string
-		returns ("","", -1) if None found"""
-	match = re.match(
-		r"\s*({})({}.*$)".format(REGEX_IDENTIFIER, REGEX_IDENTIFIER_END),
-		string, re.DOTALL
-	)
-	if match is None:
-		return ("", "", -1)
-	return match.group(1), match.group(2), match.start(2)
+    """finds the first identifier in string:
+    Returns:
+            tuple str, str, int - identifier, rest_of_string, start_of_rest_of_string
+            returns ("","", -1) if None found"""
+    match = re.match(
+        r"\s*({})({}.*$)".format(REGEX_IDENTIFIER, REGEX_IDENTIFIER_END),
+        string,
+        re.DOTALL,
+    )
+    if match is None:
+        return ("", "", -1)
+    return match.group(1), match.group(2), match.start(2)
 
 
 def is_integer(string: str) -> bool:
-	"""returns True if string can safely be converted
-	to a integer with to_integer(string)"""
-	return re.match(REGEX_INTEGER, string.strip()) is not None
+    """returns True if string can safely be converted
+    to a integer with to_integer(string)"""
+    return re.match(REGEX_INTEGER, string.strip()) is not None
+
 
 def to_integer(string: str) -> int:
-	"""converts string to integer"""
-	return int(string.strip().replace(" ", "").replace("_", ""))
+    """converts string to integer"""
+    return int(string.strip().replace(" ", "").replace("_", ""))
+
 
 def trim(docstring: str) -> str:
-	"""trim a docstring before display"""
-	if not docstring:
-		return ''
-	# Convert tabs to spaces (following the normal Python rules)
-	# and split into a list of lines:
-	lines = docstring.expandtabs().splitlines()
-	# Determine minimum indentation (first line doesn't count):
-	indent = 1000 # a large integer
-	for line in lines[1:]:
-		stripped = line.lstrip()
-		if stripped:
-			indent = min(indent, len(line) - len(stripped))
-	# Remove indentation (first line is special):
-	trimmed = [lines[0].strip()]
-	if indent < 1000:
-		for line in lines[1:]:
-			trimmed.append(line[indent:].rstrip())
-	# Strip off trailing and leading blank lines:
-	while trimmed and not trimmed[-1]:
-		trimmed.pop()
-	while trimmed and not trimmed[0]:
-		trimmed.pop(0)
-	# Return a single string:
-	return '\n'.join(trimmed)
+    """trim a docstring before display"""
+    if not docstring:
+        return ""
+    # Convert tabs to spaces (following the normal Python rules)
+    # and split into a list of lines:
+    lines = docstring.expandtabs().splitlines()
+    # Determine minimum indentation (first line doesn't count):
+    indent = 1000  # a large integer
+    for line in lines[1:]:
+        stripped = line.lstrip()
+        if stripped:
+            indent = min(indent, len(line) - len(stripped))
+    # Remove indentation (first line is special):
+    trimmed = [lines[0].strip()]
+    if indent < 1000:
+        for line in lines[1:]:
+            trimmed.append(line[indent:].rstrip())
+    # Strip off trailing and leading blank lines:
+    while trimmed and not trimmed[-1]:
+        trimmed.pop()
+    while trimmed and not trimmed[0]:
+        trimmed.pop(0)
+    # Return a single string:
+    return "\n".join(trimmed)
```

## mlpproc/errors.py

```diff
@@ -10,158 +10,170 @@
   used to raise warning
 """
 
 import enum
 
 from .context import ContextStack
 
-ANSI_ERROR   = "\033[31m" # red
-ANSI_WARNING = "\033[35m" # purple
-ANSI_RESET   = "\033[39m"
+ANSI_ERROR = "\033[31m"  # red
+ANSI_WARNING = "\033[35m"  # purple
+ANSI_RESET = "\033[39m"
+
 
 @enum.unique
 class WarningMode(enum.Enum):
-	"""Preprocessor warning modes:
-	| HIDE -> do nothing
-	| PRINT -> print to stderr
-	| PRINT_AND_RAISE -> print to stderr and raise warning
-	| RAISE -> raise python warning
-	| AS_ERROR -> passes to send_error()"""
-	HIDE = 1
-	PRINT = 2
-	PRINT_AND_RAISE = 3
-	RAISE = 4
-	AS_ERROR = 5
+    """Preprocessor warning modes:
+    | HIDE -> do nothing
+    | PRINT -> print to stderr
+    | PRINT_AND_RAISE -> print to stderr and raise warning
+    | RAISE -> raise python warning
+    | AS_ERROR -> passes to send_error()"""
+
+    HIDE = 1
+    PRINT = 2
+    PRINT_AND_RAISE = 3
+    RAISE = 4
+    AS_ERROR = 5
 
 
 @enum.unique
 class ErrorMode(enum.Enum):
-	"""Preprocessor error modes:
-	| PRINT_AND_EXIT -> print to stderr and exit
-	| PRINT_AND_RAISE -> print to stderr and raise exception
-	| RAISE -> raise exception"""
-	PRINT_AND_EXIT = 1
-	PRINT_AND_RAISE = 2
-	RAISE = 3
+    """Preprocessor error modes:
+    | PRINT_AND_EXIT -> print to stderr and exit
+    | PRINT_AND_RAISE -> print to stderr and raise exception
+    | RAISE -> raise exception"""
+
+    PRINT_AND_EXIT = 1
+    PRINT_AND_RAISE = 2
+    RAISE = 3
 
 
 class PreprocessorErrorWarningBase:
-	"""standard preprocessor error/warning class
-	PreprocessorError and PreprocessorWarning both inherit from this.
-	Attributes:
-	- name (ex : "missing-endblock")
-	- message (ex: "no matching endblock for ...")
-	- context: ContextStack (file pos)
-	- trace (ex: "filename:line:char: context_msg...")
-	"""
-
-	name: str
-	message: str
-	context: ContextStack
-	is_error: bool
-
-	def __init__(
-		self: "PreprocessorErrorWarningBase",
-		name: str, message: str, context: ContextStack, is_error: bool
-	) -> None:
-		"""Initializes the object:
-		Arguments:
-		- name (ex : "missing-endblock")
-		- message (ex: "no matching endblock for ...")
-		- context: ContextElement (file pos)
-		- is_error: false if warning
-		"""
-		self.name = name
-		self.message = message
-		self.context = context
-		self.is_error = is_error
-
-	@property
-	def position(self: "PreprocessorErrorWarningBase") -> int:
-		"""the true position (number of characters from start of file)"""
-		return self.context.top.true_position(self.context.top.position)
-
-	@property
-	def line(self: "PreprocessorErrorWarningBase") -> int:
-		"""The line number of the error"""
-		return self.context.top.file.line_number(self.position)[0]
-
-	@property
-	def char(self: "PreprocessorErrorWarningBase") -> int:
-		"""The number of characters from the start of the line"""
-		return self.context.top.file.line_number(self.position)[1]
-
-	@property
-	def filename(self: "PreprocessorErrorWarningBase") -> str:
-		"""The name of the file"""
-		return self.context.top.file.filename
-
-	def format_name(self: "PreprocessorErrorWarningBase") -> str:
-		"""formats name into -Wname or -Ename
-		depending on self.is_error"""
-		if self.is_error:
-			return "-E"+self.name
-		return "-W"+self.name
-
-	def format_message(self: "PreprocessorErrorWarningBase", ansi :bool = False) -> str:
-		"""formats the message into
-		first line [-Wname/-Ename]
-		following lines"""
-		msg = self.message.split("\n")
-		if ansi:
-			if self.is_error:
-				msg[0] += " [{}{}{}]".format(ANSI_ERROR, self.format_name(), ANSI_RESET)
-			else:
-				msg[0] += " [{}{}{}]".format(ANSI_WARNING, self.format_name(), ANSI_RESET)
-		else:
-			msg[0] += " [{}]".format(self.format_name())
-		return "\n".join(msg)
-
-	def __str__(self: "PreprocessorErrorWarningBase") -> str:
-		"""transform self into string for error display
-		ex: filename:line:char: message [name]"""
-		return "{}:{}:{}: {}".format(
-			self.filename, self.line, self.char, self.format_message()
-		)
-
-	def pretty_message(self: "PreprocessorErrorWarningBase", ansi: bool = False) -> str:
-		"""pretty prints self with trace, use ansi if specified"""
-		trace = self.context.trace()
-		if self.is_error:
-			err = "error:"
-			if ansi:
-				err = ANSI_ERROR + err + ANSI_RESET
-		else:
-			err = "warning:"
-			if ansi:
-				err = ANSI_WARNING + err + ANSI_RESET
-		return "{} {} {}".format(trace, err, self.format_message(ansi).replace("\n", "\n  "))
-
+    """standard preprocessor error/warning class
+    PreprocessorError and PreprocessorWarning both inherit from this.
+    Attributes:
+    - name (ex : "missing-endblock")
+    - message (ex: "no matching endblock for ...")
+    - context: ContextStack (file pos)
+    - trace (ex: "filename:line:char: context_msg...")
+    """
+
+    name: str
+    message: str
+    context: ContextStack
+    is_error: bool
+
+    def __init__(
+        self: "PreprocessorErrorWarningBase",
+        name: str,
+        message: str,
+        context: ContextStack,
+        is_error: bool,
+    ) -> None:
+        """Initializes the object:
+        Arguments:
+        - name (ex : "missing-endblock")
+        - message (ex: "no matching endblock for ...")
+        - context: ContextElement (file pos)
+        - is_error: false if warning
+        """
+        self.name = name
+        self.message = message
+        self.context = context
+        self.is_error = is_error
+
+    @property
+    def position(self: "PreprocessorErrorWarningBase") -> int:
+        """the true position (number of characters from start of file)"""
+        return self.context.top.true_position(self.context.top.position)
+
+    @property
+    def line(self: "PreprocessorErrorWarningBase") -> int:
+        """The line number of the error"""
+        return self.context.top.file.line_number(self.position)[0]
+
+    @property
+    def char(self: "PreprocessorErrorWarningBase") -> int:
+        """The number of characters from the start of the line"""
+        return self.context.top.file.line_number(self.position)[1]
+
+    @property
+    def filename(self: "PreprocessorErrorWarningBase") -> str:
+        """The name of the file"""
+        return self.context.top.file.filename
+
+    def format_name(self: "PreprocessorErrorWarningBase") -> str:
+        """formats name into -Wname or -Ename
+        depending on self.is_error"""
+        if self.is_error:
+            return "-E" + self.name
+        return "-W" + self.name
+
+    def format_message(self: "PreprocessorErrorWarningBase", ansi: bool = False) -> str:
+        """formats the message into
+        first line [-Wname/-Ename]
+        following lines"""
+        msg = self.message.split("\n")
+        if ansi:
+            if self.is_error:
+                msg[0] += " [{}{}{}]".format(ANSI_ERROR, self.format_name(), ANSI_RESET)
+            else:
+                msg[0] += " [{}{}{}]".format(
+                    ANSI_WARNING, self.format_name(), ANSI_RESET
+                )
+        else:
+            msg[0] += " [{}]".format(self.format_name())
+        return "\n".join(msg)
+
+    def __str__(self: "PreprocessorErrorWarningBase") -> str:
+        """transform self into string for error display
+        ex: filename:line:char: message [name]"""
+        return "{}:{}:{}: {}".format(
+            self.filename, self.line, self.char, self.format_message()
+        )
+
+    def pretty_message(self: "PreprocessorErrorWarningBase", ansi: bool = False) -> str:
+        """pretty prints self with trace, use ansi if specified"""
+        trace = self.context.trace()
+        if self.is_error:
+            err = "error:"
+            if ansi:
+                err = ANSI_ERROR + err + ANSI_RESET
+        else:
+            err = "warning:"
+            if ansi:
+                err = ANSI_WARNING + err + ANSI_RESET
+        return "{} {} {}".format(
+            trace, err, self.format_message(ansi).replace("\n", "\n  ")
+        )
 
 
 class PreprocessorError(PreprocessorErrorWarningBase, Exception):
-	"""The standard class for preprocessor errors"""
-	def __init__(
-		self: "PreprocessorError", name: str, message: str, context: ContextStack
-	) -> None:
-		"""Initializes the object:
-		Arguments:
-		- name (ex : "missing-endblock")
-		- message (ex: "no matching endblock for ...")
-		- context: ContextElement (file pos)
-		"""
-		PreprocessorErrorWarningBase.__init__(self, name, message, context, True)
-		Exception.__init__(self, PreprocessorErrorWarningBase.__str__(self))
+    """The standard class for preprocessor errors"""
+
+    def __init__(
+        self: "PreprocessorError", name: str, message: str, context: ContextStack
+    ) -> None:
+        """Initializes the object:
+        Arguments:
+        - name (ex : "missing-endblock")
+        - message (ex: "no matching endblock for ...")
+        - context: ContextElement (file pos)
+        """
+        PreprocessorErrorWarningBase.__init__(self, name, message, context, True)
+        Exception.__init__(self, PreprocessorErrorWarningBase.__str__(self))
+
 
 class PreprocessorWarning(PreprocessorErrorWarningBase, Warning):
-	"""The standard class for preprocessor warnings"""
-	def __init__(
-		self: "PreprocessorWarning", name: str, message: str, context: ContextStack
-	) -> None:
-		"""Initializes the object:
-		Arguments:
-		- name (ex : "missing-endblock")
-		- message (ex: "no matching endblock for ...")
-		- context: ContextElement (file pos)
-		"""
-		PreprocessorErrorWarningBase.__init__(self, name, message, context, False)
-		Warning.__init__(self, PreprocessorErrorWarningBase.__str__(self))
+    """The standard class for preprocessor warnings"""
+
+    def __init__(
+        self: "PreprocessorWarning", name: str, message: str, context: ContextStack
+    ) -> None:
+        """Initializes the object:
+        Arguments:
+        - name (ex : "missing-endblock")
+        - message (ex: "no matching endblock for ...")
+        - context: ContextElement (file pos)
+        """
+        PreprocessorErrorWarningBase.__init__(self, name, message, context, False)
+        Warning.__init__(self, PreprocessorErrorWarningBase.__str__(self))
```

## mlpproc/final_actions.py

```diff
@@ -3,321 +3,359 @@
 and the commands that trigger them
 """
 import argparse
 import re
 from typing import Optional
 
 from .defs import REGEX_IDENTIFIER_WRAPPED, ArgumentParserNoExit
-from .preprocessor import Preprocessor, TypeCommand, TypeFinalAction
+from .preprocessor import Command, Preprocessor
 
 
-def final_action_command(function: TypeFinalAction, name: Optional[str] = None
-) -> TypeCommand:
-	"""generates a simple command to add the final action function
-	returns cmd which queues function to final actions.
-	cmd.doc is generated by function.doc or function.__doc__"""
-	true_name = name if isinstance(name, str) else function.__name__.replace("fnl_", "")
-	def command(preprocessor: Preprocessor, args_str: str) -> str:
-		"""Command queuing function as post action"""
-		if args_str.strip() != "":
-			preprocessor.send_warning("extra-arguments", "{} takes no arguments".format(true_name))
-		preprocessor.final_actions.append(function)
-		return ""
-
-	command.__doc__ = function.doc if hasattr(function, "doc") else function.__doc__ # type: ignore
-	command.doc = command.__doc__ # type: ignore
-	return command
-
-def final_action_replace(preprocessor: Preprocessor, string: str,
-	pattern: str, replacement: str, flags: re.RegexFlag, count:int = 0) -> str:
-	"""same as string = re.sub(pattern, replacement, string)
-	but uses preprocessor string_replace to offset labels correctly"""
-	matches = []
-	for re_match in re.finditer(pattern, string, flags=flags):
-		matches.append((re_match.start(), re_match.end(), re_match.group()))
-	replaced_nb = 0
-	while matches:
-		match = matches[0]
-		local_repl = re.sub(pattern, replacement, match[2], flags=flags)
-		string = preprocessor.replace_string(match[0], match[1], string, local_repl, matches)
-		replaced_nb += 1
-		if replaced_nb == count:
-			return string
-		if matches and match == matches[0]:
-			del matches[0]
-	return string
+class FinalActionCommand(Command):
+    """generates a simple command to add the final action function
+    returns cmd which queues function to final actions.
+    cmd.doc is generated by function.doc or function.__doc__"""
+
+    name: Optional[str] = None
+
+    # true_name = name if isinstance(name, str) else function.__name__.replace("fnl_", "")
+
+    def final_action(self, preprocessor: Preprocessor, args_str: str) -> str:
+        raise ValueError("Override in child classes")
+
+    def __call__(self, preprocessor: Preprocessor, args_str: str) -> str:
+        """Command queuing function as post action"""
+        if args_str.strip() != "":
+            preprocessor.send_warning(
+                "extra-arguments", "{} takes no arguments".format(self.name)
+            )
+        preprocessor.final_actions.append(self.final_action)
+        return ""
+
+
+def final_action_replace(
+    preprocessor: Preprocessor,
+    string: str,
+    pattern: str,
+    replacement: str,
+    flags: re.RegexFlag,
+    count: int = 0,
+) -> str:
+    """same as string = re.sub(pattern, replacement, string)
+    but uses preprocessor string_replace to offset labels correctly"""
+    matches = []
+    for re_match in re.finditer(pattern, string, flags=flags):
+        matches.append((re_match.start(), re_match.end(), re_match.group()))
+    replaced_nb = 0
+    while matches:
+        match = matches[0]
+        local_repl = re.sub(pattern, replacement, match[2], flags=flags)
+        string = preprocessor.replace_string(
+            match[0], match[1], string, local_repl, matches
+        )
+        replaced_nb += 1
+        if replaced_nb == count:
+            return string
+        if matches and match == matches[0]:
+            del matches[0]
+    return string
+
 
 # ============================================================
 # strip commands
 # ============================================================
 
 
-def fnl_strip_empty_lines(preprocessor: Preprocessor, string: str) -> str:
-	"""final action to remove empty lines (containing whitespace only) from the text"""
-	return final_action_replace(preprocessor, string, r"\n\s*\n", "\n", preprocessor.re_flags)
-
-fnl_strip_empty_lines.doc = ( # type: ignore
-	"""
-	Removes empty lines (lines containing only spaces)
-	""")
-
-def fnl_strip_leading_whitespace(preprocessor: Preprocessor, string: str) -> str:
-	"""final action to remove leading whitespace (indent) from string"""
-	return final_action_replace(preprocessor, string, "^[ \t]+", "", re.MULTILINE)
-
-fnl_strip_leading_whitespace.doc = ( # type: ignore
-	"""
-	Removes leading whitespace (indent)
-	""")
-
-def fnl_strip_trailing_whitespace(preprocessor: Preprocessor, string: str) -> str:
-	"""final action to remove trailing whitespace (indent) from string"""
-	return final_action_replace(preprocessor, string, "[ \t]+$", "", re.MULTILINE)
-
-fnl_strip_trailing_whitespace.doc = ( # type: ignore
-	"""
-	Removes trailing whitespace
-	""")
-
-def fnl_fix_last_line(preprocessor: Preprocessor, string: str) -> str:
-	"""final action to ensures file ends with an empty line if
-	it is not empty"""
-	if string and string[-1] != "\n":
-		string += "\n"
-	else:
-		ii = len(string) - 2
-		while ii >= 0 and string[ii] == "\n":
-			ii -= 1
-		string = preprocessor.replace_string(ii+2, len(string), string, "", [])
-	return string
-
-fnl_fix_last_line.doc = ( # type: ignore
-	"""
-	Ensures the file ends with a single empty
-	line (unless it is empty)
-	""")
-
-def fnl_fix_first_line(preprocessor: Preprocessor, string: str) -> str:
-	"""final action to ensures file starts with a non-empty
-	non-whitespace line (if it is not empty)"""
-	while string != "":
-		pos = string.find("\n")
-		if pos == -1:
-			if string.isspace():
-				return preprocessor.replace_string(0, len(string), string, "", [])
-			return string
-		if string[:pos+1].isspace():
-			string = preprocessor.replace_string(0, pos+1, string, "", [])
-		else:
-			break
-	return string
-
-fnl_fix_first_line.doc = ( # type: ignore
-	"""
-	Ensures the document starts with a non-empty
-	line (unless it is empty)
-	""")
-
-def cmd_strip(preprocessor: Preprocessor, args: str) -> str:
-	"""the strip command
-	queues:
-	- fnl_strip_empty_lines
-	- fnl_strip_leading_whitespace
-	- fnl_strip_trailing_whitespace
-	- fnl_fix_first_line
-	- fnl_fix_last_line
-	to preprocessor final actions"""
-	if args.strip() != "":
-		preprocessor.send_warning("extra-arguments", "strip takes no arguments")
-	preprocessor.final_actions.append(fnl_strip_empty_lines)
-	preprocessor.final_actions.append(fnl_strip_leading_whitespace)
-	preprocessor.final_actions.append(fnl_strip_trailing_whitespace)
-	preprocessor.final_actions.append(fnl_fix_first_line)
-	preprocessor.final_actions.append(fnl_fix_last_line)
-	return ""
-
-cmd_strip.doc = ( # type: ignore
-	"""
-	Removes empty lines as well as trailing/leading whitespace.
-	Ensures file ends on a single empty line
-	""")
+class Cmd_StripEmptyLines(FinalActionCommand):
+    def final_action(self, preprocessor: Preprocessor, string: str) -> str:
+        """final action to remove empty lines (containing whitespace only) from the text"""
+        return final_action_replace(
+            preprocessor, string, r"\n\s*\n", "\n", preprocessor.re_flags
+        )
+
+    doc = """
+        Removes empty lines (lines containing only spaces)
+        """
+
+
+class Cmd_StripLeadingWhitespace(FinalActionCommand):
+    def final_action(self, preprocessor: Preprocessor, string: str) -> str:
+        """final action to remove leading whitespace (indent) from string"""
+        return final_action_replace(preprocessor, string, "^[ \t]+", "", re.MULTILINE)
+
+    doc = """
+        Removes leading whitespace (indent)
+        """
+
+
+class Cmd_StripTrailingWhitespace(FinalActionCommand):
+    def final_action(self, preprocessor: Preprocessor, string: str) -> str:
+        """final action to remove trailing whitespace (indent) from string"""
+        return final_action_replace(preprocessor, string, "[ \t]+$", "", re.MULTILINE)
+
+    doc = """
+        Removes trailing whitespace
+        """
+
+
+class Cmd_FixLastLine(FinalActionCommand):
+    def final_action(self, preprocessor: Preprocessor, string: str) -> str:
+        """final action to ensures file ends with an empty line if
+        it is not empty"""
+        if string and string[-1] != "\n":
+            string += "\n"
+        else:
+            ii = len(string) - 2
+            while ii >= 0 and string[ii] == "\n":
+                ii -= 1
+            string = preprocessor.replace_string(ii + 2, len(string), string, "", [])
+        return string
+
+    doc = """
+        Ensures the file ends with a single empty
+        line (unless it is empty)
+        """
+
+
+class Cmd_FixFirstLine(FinalActionCommand):
+    def final_action(self, preprocessor: Preprocessor, string: str) -> str:
+        """final action to ensures file starts with a non-empty
+        non-whitespace line (if it is not empty)"""
+        while string != "":
+            pos = string.find("\n")
+            if pos == -1:
+                if string.isspace():
+                    return preprocessor.replace_string(0, len(string), string, "", [])
+                return string
+            if string[: pos + 1].isspace():
+                string = preprocessor.replace_string(0, pos + 1, string, "", [])
+            else:
+                break
+        return string
+
+    doc = """
+        Ensures the document starts with a non-empty
+        line (unless it is empty)
+        """
+
+
+class Cmd_Strip(Command):
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the strip command
+        queues:
+        - fnl_strip_empty_lines
+        - fnl_strip_leading_whitespace
+        - fnl_strip_trailing_whitespace
+        - fnl_fix_first_line
+        - fnl_fix_last_line
+        to preprocessor final actions"""
+        if args.strip() != "":
+            preprocessor.send_warning("extra-arguments", "strip takes no arguments")
+        preprocessor.final_actions.append(Cmd_StripEmptyLines().final_action)
+        preprocessor.final_actions.append(Cmd_StripLeadingWhitespace().final_action)
+        preprocessor.final_actions.append(Cmd_StripTrailingWhitespace().final_action)
+        preprocessor.final_actions.append(Cmd_FixFirstLine().final_action)
+        preprocessor.final_actions.append(Cmd_FixLastLine().final_action)
+        return ""
+
+    doc = """
+        Removes empty lines as well as trailing/leading whitespace.
+        Ensures file ends on a single empty line
+        """
+
 
 # ============================================================
 # replace command
 # ============================================================
 
 
-replace_parser = ArgumentParserNoExit(
-	prog="replace", add_help=False
-)
-
-replace_parser.add_argument("--regex", "-r", action="store_true")
-replace_parser.add_argument("--ignore-case", "-i", action="store_true")
-replace_parser.add_argument("--whole-word", "-w", action="store_true")
-replace_parser.add_argument("--count", "-c", nargs='?', default=0, type=int)
-replace_parser.add_argument("pattern")
-replace_parser.add_argument("replacement")
-replace_parser.add_argument("text", nargs="?", default=None, action="store")
-
-def cmd_replace(preprocessor: Preprocessor, args: str) -> str:
-	"""the replace command
-	usage: replace [-r|--regex] [-i|--ignore-case] [-w|--whole-word]
-	               [-c|--count <number>] pattern replacement [text]
-		if text is present, replace in text and print
-		else queue final action to replace in current block
-	"""
-	split = preprocessor.split_args(args)
-	try:
-		arguments = replace_parser.parse_args(split)
-	except argparse.ArgumentError:
-		preprocessor.send_error("invalid-argument",
-			"invalid argument.\n"
-			"usage: replace [-r|--regex] [-i|--ignore-case] [-w|--whole-word]\n"
-			"               [-c|--count <number>] pattern replacement [text]")
-	flags = re.MULTILINE
-	pattern = arguments.pattern
-	repl = arguments.replacement
-	if arguments.ignore_case:
-		flags |= re.IGNORECASE
-	if arguments.regex:
-		if arguments.whole_word:
-			preprocessor.send_error("invalid-argument","incompatible arguments : --regex and --whole-word")
-	else:
-		pattern = re.escape(pattern)
-		if arguments.whole_word:
-			pattern = REGEX_IDENTIFIER_WRAPPED.format(pattern)
-			repl = "\\1{}\\3".format(repl)
-	count = arguments.count
-	if count < 0:
-		preprocessor.send_error("invalid-argument",
-			"invalid argument.\nthe replace --count argument must be positive"
-		)
-	pos = preprocessor.current_position.cmd_begin
-	if arguments.text is not None:
-		try:
-			return re.sub(pattern, repl, arguments.text, count=count, flags = flags)
-		except re.error as err:
-			preprocessor.send_error("invalid-argument","replace regex error: {}".format(err.msg))
-			return ""
-	# no text, queue post action
-	def fnl_replace(preprocessor: Preprocessor, string: str) -> str:
-		try:
-			return final_action_replace(preprocessor, string, pattern, repl, flags, count=count)
-		except re.error as err:
-			preprocessor.context.update(pos)
-			preprocessor.send_error("invalid-argument","replace regex error: {}".format(err.msg))
-			preprocessor.context.pop()
-			return ""
-	fnl_replace.__name__ = "fnl_replace_lambda"
-	fnl_replace.__doc__ = "final action for replace {}".format(args)
-	preprocessor.final_actions.append(fnl_replace)
-	return ""
-
-cmd_replace.doc = ( # type: ignore
-	"""
-	Used to find and replace text
-
-	Usage: replace [--options] pattern replacement [text]
-
-	If text is present, replacement takes place in text.
-	else it takes place in the whole document (can be restricted with block)
-
-	Options:
-	  -c --count <number> number of occurrences to replace (default all)
-	  -i --ignore-case    pattern search ignores case (foo will match foo,FoO,FOO...)
-	  -w --whole-word     pattern only matches full words, i.e. occurrences not directly
-	                      preceded/followed by a letter/number/underscore.
-	  -r --regex          pattern is a regular expression, capture groups can be placed
-	                      in replacement with \\1, \\2,...
-	                      incompatible with --whole-word
-	""")
+class Cmd_Replace(Command):
+    parser = ArgumentParserNoExit(prog="replace", add_help=False)
+
+    parser.add_argument("--regex", "-r", action="store_true")
+    parser.add_argument("--ignore-case", "-i", action="store_true")
+    parser.add_argument("--whole-word", "-w", action="store_true")
+    parser.add_argument("--count", "-c", nargs="?", default=0, type=int)
+    parser.add_argument("pattern")
+    parser.add_argument("replacement")
+    parser.add_argument("text", nargs="?", default=None, action="store")
+
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """the replace command
+        usage: replace [-r|--regex] [-i|--ignore-case] [-w|--whole-word]
+                    [-c|--count <number>] pattern replacement [text]
+                if text is present, replace in text and print
+                else queue final action to replace in current block
+        """
+        split = preprocessor.split_args(args)
+        try:
+            arguments = self.parser.parse_args(split)
+        except argparse.ArgumentError:
+            preprocessor.send_error(
+                "invalid-argument",
+                "invalid argument.\n"
+                "usage: replace [-r|--regex] [-i|--ignore-case] [-w|--whole-word]\n"
+                "               [-c|--count <number>] pattern replacement [text]",
+            )
+        flags = re.MULTILINE
+        pattern: str = arguments.pattern
+        repl = arguments.replacement
+        if arguments.ignore_case:
+            flags |= re.IGNORECASE
+        if arguments.regex:
+            if arguments.whole_word:
+                preprocessor.send_error(
+                    "invalid-argument",
+                    "incompatible arguments : --regex and --whole-word",
+                )
+        else:
+            pattern = re.escape(pattern)
+            if arguments.whole_word:
+                pattern = REGEX_IDENTIFIER_WRAPPED.format(pattern)
+                repl = "\\1{}\\3".format(repl)
+        count = arguments.count
+        if count < 0:
+            preprocessor.send_error(
+                "invalid-argument",
+                "invalid argument.\nthe replace --count argument must be positive",
+            )
+        pos = preprocessor.current_position.cmd_begin
+        if arguments.text is not None:
+            try:
+                return re.sub(pattern, repl, arguments.text, count=count, flags=flags)
+            except re.error as err:
+                preprocessor.send_error(
+                    "invalid-argument", "replace regex error: {}".format(err.msg)
+                )
+                return ""
+
+        # no text, queue post action
+        def fnl_replace(preprocessor: Preprocessor, string: str) -> str:
+            try:
+                return final_action_replace(
+                    preprocessor, string, pattern, repl, flags, count=count
+                )
+            except re.error as err:
+                preprocessor.context.update(pos)
+                preprocessor.send_error(
+                    "invalid-argument", "replace regex error: {}".format(err.msg)
+                )
+                preprocessor.context.pop()
+                return ""
+
+        fnl_replace.__name__ = "fnl_replace_lambda"
+        fnl_replace.__doc__ = "final action for replace {}".format(args)
+        preprocessor.final_actions.append(fnl_replace)
+        return ""
+
+    doc = """
+        Used to find and replace text
+
+        Usage: replace [--options] pattern replacement [text]
+
+        If text is present, replacement takes place in text.
+        else it takes place in the whole document (can be restricted with block)
+
+        Options:
+        -c --count <number> number of occurrences to replace (default all)
+        -i --ignore-case    pattern search ignores case (foo will match foo,FoO,FOO...)
+        -w --whole-word     pattern only matches full words, i.e. occurrences not directly
+                            preceded/followed by a letter/number/underscore.
+        -r --regex          pattern is a regular expression, capture groups can be placed
+                            in replacement with \\1, \\2,...
+                            incompatible with --whole-word
+        """
+
 
 # ============================================================
 # upper/lower/capitalize commands
 # ============================================================
 
-def fnl_upper(_: Preprocessor, string: str) -> str:
-	"""Final action for upper, transforms
-	text in string to UPPER CASE"""
-	return string.upper()
-
-def cmd_upper(preprocessor: Preprocessor, args: str) -> str:
-	"""The upper command, switches text to UPPER CASE
-	usage: upper [text]
-		with text -> returns TEXT (ignores trailing/leading spaces)
-		without   -> queues final action to transform all text in current block
-			to UPPER CASE"""
-	args = args.strip()
-	if args:
-		if len(args) >= 2 and args[0] == '"' and args[-1] == '"':
-			args = args[0:-1]
-		return args.upper()
-	preprocessor.final_actions.append(fnl_upper)
-	return ""
-
-cmd_upper.doc = ( # type: ignore
-	"""
-	Converts text to UPPER CASE
-
-	usage: upper [text]
-
-	If text is present, converts text
-	else converts everything in the document (can be restricted with block).
-	""")
-
-def fnl_lower(_: Preprocessor, string: str) -> str:
-	"""Final action for upper, transforms
-	text in string to lower case"""
-	return string.lower()
-
-def cmd_lower(preprocessor: Preprocessor, args: str) -> str:
-	"""The lower command, switches text to lower case
-	usage: lower [text]
-		with TEXT -> returns text (ignores trailing/leading spaces)
-		without   -> queues final action to transform all text in current block
-			to lower case"""
-	args = args.strip()
-	if args:
-		if len(args) >= 2 and args[0] == '"' and args[-1] == '"':
-			args = args[0:-1]
-		return args.lower()
-	preprocessor.final_actions.append(fnl_lower)
-	return ""
-
-cmd_lower.doc = ( # type: ignore
-	"""
-	Converts text to lower case
-
-	usage: lower [text]
-
-	If text is present, converts text
-	else converts everything in the document (can be restricted with block).
-	""")
-
-def fnl_capitalize(_: Preprocessor, string: str) -> str:
-	"""Final action for upper, transforms
-	text in string to Capitalized Case"""
-	return string.capitalize()
-
-def cmd_capitalize(preprocessor: Preprocessor, args: str) -> str:
-	"""The capitalize command, switches text to lower case
-	usage: capitalize [text]
-		with text -> returns Text (ignores trailing/leading spaces)
-		without   -> queues final action to transform all text in document
-	    (can be restricted with block) to Capitalized Case"""
-	args = args.strip()
-	if args:
-		if len(args) >= 2 and args[0] == '"' and args[-1] == '"':
-			args = args[0:-1]
-		return args.capitalize()
-	preprocessor.final_actions.append(fnl_capitalize)
-	return ""
-
-cmd_capitalize.doc = ( # type: ignore
-	"""
-	Converts text to Capitalized case
-
-	usage: capitalize [text]
-
-	If text is present, converts text
-	else converts everything in the document (can be restricted with block).
-	""")
+
+class Cmd_Upper(Command):
+    def final_action(self, _: Preprocessor, string: str) -> str:
+        """Final action for upper, transforms
+        text in string to UPPER CASE"""
+        return string.upper()
+
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """The upper command, switches text to UPPER CASE
+        usage: upper [text]
+                with text -> returns TEXT (ignores trailing/leading spaces)
+                without   -> queues final action to transform all text in current block
+                        to UPPER CASE"""
+        args = args.strip()
+        if args:
+            if len(args) >= 2 and args[0] == '"' and args[-1] == '"':
+                args = args[0:-1]
+            return args.upper()
+        preprocessor.final_actions.append(self.final_action)
+        return ""
+
+    doc = """
+        Converts text to UPPER CASE
+
+        usage: upper [text]
+
+        If text is present, converts text
+        else converts everything in the document (can be restricted with block).
+        """
+
+
+class Cmd_Lower(Command):
+    def final_action(self, _: Preprocessor, string: str) -> str:
+        """Final action for upper, transforms
+        text in string to lower case"""
+        return string.lower()
+
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """The lower command, switches text to lower case
+        usage: lower [text]
+                with TEXT -> returns text (ignores trailing/leading spaces)
+                without   -> queues final action to transform all text in current block
+                        to lower case"""
+        args = args.strip()
+        if args:
+            if len(args) >= 2 and args[0] == '"' and args[-1] == '"':
+                args = args[0:-1]
+            return args.lower()
+        preprocessor.final_actions.append(self.final_action)
+        return ""
+
+    doc = """
+        Converts text to lower case
+
+        usage: lower [text]
+
+        If text is present, converts text
+        else converts everything in the document (can be restricted with block).
+        """
+
+
+class Cmd_Capitalize(Command):
+    def final_action(self, _: Preprocessor, string: str) -> str:
+        """Final action for upper, transforms
+        text in string to Capitalized Case"""
+        return string.capitalize()
+
+    def __call__(self, preprocessor: Preprocessor, args: str) -> str:
+        """The capitalize command, switches text to lower case
+        usage: capitalize [text]
+                with text -> returns Text (ignores trailing/leading spaces)
+                without   -> queues final action to transform all text in document
+            (can be restricted with block) to Capitalized Case"""
+        args = args.strip()
+        if args:
+            if len(args) >= 2 and args[0] == '"' and args[-1] == '"':
+                args = args[0:-1]
+            return args.capitalize()
+        preprocessor.final_actions.append(self.final_action)
+        return ""
+
+    doc = """
+        Converts text to Capitalized case
+
+        usage: capitalize [text]
+
+        If text is present, converts text
+        else converts everything in the document (can be restricted with block).
+        """
```

## mlpproc/labels.py

```diff
@@ -3,118 +3,123 @@
 - labels are grouped """
 
 
 from typing import Dict, List
 
 
 class LabelStackError(ValueError):
-	"""Abstract class for LabelStackErrors"""
+    """Abstract class for LabelStackErrors"""
 
 
 class EmptyLabelStack(LabelStackError):
-	"""raised when trying to add/retrive labels
-	from an EmptyStack"""
+    """raised when trying to add/retrive labels
+    from an EmptyStack"""
 
 
 class TooShortLabelStack(LabelStackError):
-	"""Raised when trying to collapse an
-	empty or 1-deep stack"""
+    """Raised when trying to collapse an
+    empty or 1-deep stack"""
+
 
 class LabelStack:
-	"""a stack of labels,
-	each layer contains position relative
-	to the start of the current string being parsed"""
-
-	_stack: List[Dict[str, List[int]]]
-
-	def __init__(self: "LabelStack") -> None:
-		"""initializes label stack"""
-		self._stack = []
-
-	@property
-	def height(self: "LabelStack") -> int:
-		"""The height of the stack, should match
-		Preprocessor._recursion_depth"""
-		return len(self._stack)
-
-	@property
-	def top_level(self: "LabelStack") -> Dict[str, List[int]]:
-		"""Returns the top level of the stack"""
-		if self.height == 0:
-			raise EmptyLabelStack("Canno't access toplevel of an empty stack")
-		return self._stack[-1]
-
-	def add_label(self: "LabelStack", label: str, pos: int) -> None:
-		"""Adds a label to the toplevel
-		pos should be relative to the string start (i.e. Position.relative_XXX)
-		"""
-		toplevel = self.top_level
-		if label in toplevel:
-			toplevel[label].append(pos)
-		else:
-			toplevel[label] = [pos]
-
-	def get_label(self: "LabelStack", label: str) -> List[int]:
-		"""returns a list of positions of label on the current level"""
-		toplevel = self.top_level
-		if label in toplevel:
-			return toplevel[label]
-		return []
-
-	def new_level(self: "LabelStack") -> None:
-		"""Adds a new label level"""
-		self._stack.append(dict())
-
-	def pop_level(self: "LabelStack", offset: int) -> None:
-		"""Collapses a level
-		offset is the position of the start of toplevel string
-		relative to the start of the previous one"""
-		if self.height < 2:
-			raise TooShortLabelStack("Label Stack height should be at least 2 to pop a level")
-		for label in self._stack[-1]:
-			offset_pos = [pos + offset for pos in self._stack[-1][label]]
-			if label in self._stack[-2]:
-				self._stack[-2][label].extend(offset_pos)
-			else:
-				self._stack[-2][label] = offset_pos
-		del self._stack[-1]
-
-	def forget_level(self: "LabelStack") -> None:
-		"""Forgets the topmost level and returns to the previous one"""
-		if self.height == 0:
-			raise EmptyLabelStack("Canno't forget level on empty stack")
-		del self._stack[-1]
-
-	@staticmethod
-	def _dilate_list(lst: List[int], pos: int, value: int) -> List[int]:
-		"""returns the dilated list"""
-		new_list = []
-		for val in lst:
-			if val > pos:
-				new_list.append(val + value)
-			else:
-				new_list.append(val)
-		return new_list
-
-	def dilate_level(self: "LabelStack", level: int, pos: int, value: int) -> None:
-		"""dilates a level (used to signal an insertion/deletion)
-		level is the level to dilate (should be preprocessor._recursion_depth)
-		  can be -1 for topmost level
-		pos it the position where insertion/deletion takes place
-		value is the value of the dilatation (positive for insertion, negative for deletion)
-		"""
-		if self.height == 0:
-			raise EmptyLabelStack("Cannot dilate level in empty stack")
-		if -self.height >= level or level >= self.height:
-			raise IndexError("height should be between {} and {}, got {}".format(
-				-self.height+1, self.height-1, level
-			))
-		new_level = dict()
-		for label in self._stack[level]:
-			new_level[label] = self._dilate_list(self._stack[level][label], pos, value)
-		self._stack[level] = new_level
-
-	def copy(self: "LabelStack") -> "LabelStack":
-		"""returns and independent copy of self"""
-		new = LabelStack()
-		new._stack = [level.copy() for level in self._stack]
-		return new
+    """a stack of labels,
+    each layer contains position relative
+    to the start of the current string being parsed"""
+
+    _stack: List[Dict[str, List[int]]]
+
+    def __init__(self: "LabelStack") -> None:
+        """initializes label stack"""
+        self._stack = []
+
+    @property
+    def height(self: "LabelStack") -> int:
+        """The height of the stack, should match
+        Preprocessor._recursion_depth"""
+        return len(self._stack)
+
+    @property
+    def top_level(self: "LabelStack") -> Dict[str, List[int]]:
+        """Returns the top level of the stack"""
+        if self.height == 0:
+            raise EmptyLabelStack("Canno't access toplevel of an empty stack")
+        return self._stack[-1]
+
+    def add_label(self: "LabelStack", label: str, pos: int) -> None:
+        """Adds a label to the toplevel
+        pos should be relative to the string start (i.e. Position.relative_XXX)
+        """
+        toplevel = self.top_level
+        if label in toplevel:
+            toplevel[label].append(pos)
+        else:
+            toplevel[label] = [pos]
+
+    def get_label(self: "LabelStack", label: str) -> List[int]:
+        """returns a list of positions of label on the current level"""
+        toplevel = self.top_level
+        if label in toplevel:
+            return toplevel[label]
+        return []
+
+    def new_level(self: "LabelStack") -> None:
+        """Adds a new label level"""
+        self._stack.append(dict())
+
+    def pop_level(self: "LabelStack", offset: int) -> None:
+        """Collapses a level
+        offset is the position of the start of toplevel string
+        relative to the start of the previous one"""
+        if self.height < 2:
+            raise TooShortLabelStack(
+                "Label Stack height should be at least 2 to pop a level"
+            )
+        for label in self._stack[-1]:
+            offset_pos = [pos + offset for pos in self._stack[-1][label]]
+            if label in self._stack[-2]:
+                self._stack[-2][label].extend(offset_pos)
+            else:
+                self._stack[-2][label] = offset_pos
+        del self._stack[-1]
+
+    def forget_level(self: "LabelStack") -> None:
+        """Forgets the topmost level and returns to the previous one"""
+        if self.height == 0:
+            raise EmptyLabelStack("Canno't forget level on empty stack")
+        del self._stack[-1]
+
+    @staticmethod
+    def _dilate_list(lst: List[int], pos: int, value: int) -> List[int]:
+        """returns the dilated list"""
+        new_list = []
+        for val in lst:
+            if val > pos:
+                new_list.append(val + value)
+            else:
+                new_list.append(val)
+        return new_list
+
+    def dilate_level(self: "LabelStack", level: int, pos: int, value: int) -> None:
+        """dilates a level (used to signal an insertion/deletion)
+        level is the level to dilate (should be preprocessor._recursion_depth)
+          can be -1 for topmost level
+        pos it the position where insertion/deletion takes place
+        value is the value of the dilatation (positive for insertion, negative for deletion)
+        """
+        if self.height == 0:
+            raise EmptyLabelStack("Cannot dilate level in empty stack")
+        if -self.height >= level or level >= self.height:
+            raise IndexError(
+                "height should be between {} and {}, got {}".format(
+                    -self.height + 1, self.height - 1, level
+                )
+            )
+        new_level = dict()
+        for label in self._stack[level]:
+            new_level[label] = self._dilate_list(self._stack[level][label], pos, value)
+        self._stack[level] = new_level
+
+    def copy(self: "LabelStack") -> "LabelStack":
+        """returns and independent copy of self"""
+        new = LabelStack()
+        new._stack = [level.copy() for level in self._stack]
+        return new
```

## mlpproc/preprocessor.py

```diff
@@ -2,509 +2,600 @@
 Definitions of the actual Preprocessor class
 """
 import re
 from sys import stderr
 from typing import Any, Callable, Dict, List, Tuple
 
 from .context import ContextStack, FileDescriptor
-from .defs import *
-from .errors import (ErrorMode, PreprocessorError, PreprocessorWarning,
-                     WarningMode)
+from .defs import (
+    PREPROCESSOR_NAME,
+    PREPROCESSOR_VERSION,
+    REGEX_IDENTIFIER_END,
+    Position,
+    TokenMatch,
+    get_identifier_name,
+    process_string,
+    trim,
+)
+from .errors import ErrorMode, PreprocessorError, PreprocessorWarning, WarningMode
 from .labels import LabelStack
 
+
+class Command:
+    """A generic command: a function that takes the preprocessor
+    object as well a the string of arguments and generates an output string"""
+
+    doc: str
+
+    def __call__(self, preproc: "Preprocessor", args: str) -> str:
+        raise ValueError("Overwrite __call__ in subclasses")
+
+
+class Block:
+    """A generic block: a function that takes the preprocessor
+    object, a the string of arguments and a content string (unparsed)
+    and generates an output string"""
+
+    doc: str
+
+    def __call__(self, preproc: "Preprocessor", args: str, content: str) -> str:
+        raise ValueError("Overwrite __call__ in subclasses")
+
+
 TokenList = List[Tuple[int, int, TokenMatch]]
-TypeCommand = Callable[["Preprocessor", str], str]
-TypeBlock = Callable[["Preprocessor", str, str], str]
-TypeFinalAction = Callable[["Preprocessor", str], str]
+
 
 class Preprocessor:
-	"""This class implements the preprocessor:
+    """This class implements the preprocessor:
 
-	Useful attributes that can be configured:
-	- max_recursion_depth: int (default 20) - raises an error past this depth
-	- token_begin and token_end: str (default "{%" and "%}")
-	    use these to change the token used around preprocessor calls
-	    in the document.
-	    They should not be equal or be a simple double quote " or paranthese ( or )
-	- token_endblock: str (default "end")
-	    Used to specify what form the endblock command takes
-	    (with the regex <token_begin>\\s*<token_endblock><block_name>\\s*<token_end>)
-	- safe_calls: bool (default True)
-	    if True, catches exceptions raised by command or blocks
-	- error_mode: ErrorMode (default RAISE)
-	    | PRINT_AND_EXIT -> print to stderr and exit
-	    | PRINT_AND_RAISE -> print to stderr and raise exception
-	    | RAISE -> raise exception"
-	- warning_mode: WarningMode (default RAISE)
-      | HIDE -> do nothing
-      | PRINT -> print to stderr
-      | RAISE -> raise python warning
-      | AS_ERROR -> passes to self.send_error()
-	- use_color: bool (default False)
-	    if True, uses ansi color when priting errors
-	"""
-
-	# constants
-	max_recursion_depth: int = 20
-	token_begin: str = "{%"
-	token_end: str = "%}"
-	token_endblock: str = "end"
-	re_flags: re.RegexFlag = re.MULTILINE
-	exit_code: int = 4
-	safe_calls: bool = True
-	use_color: bool = False
-	string_delimiters: str = "\"'"
-
-	# warning and error modes
-	error_mode: ErrorMode = ErrorMode.RAISE
-	warning_mode: WarningMode = WarningMode.RAISE
-	silent_warnings: List[str] = []
-
-	# private attributes
-	_recursion_depth: int
-
-	# commands and blocks
-	commands: Dict[str, TypeCommand] = dict()
-	blocks: Dict[str, TypeBlock] = dict()
-	command_vars: Dict[str, Any] = dict()
-	final_actions: List[TypeFinalAction] = []
-
-	# useful variables
-	labels: LabelStack
-	context: ContextStack
-	current_position: Position
-	include_path: List[str]
-
-
-	def __init__(self):
-		self.commands = Preprocessor.commands.copy()
-		self.blocks = Preprocessor.blocks.copy()
-		self.final_actions = Preprocessor.final_actions.copy()
-		self.command_vars = Preprocessor.command_vars.copy()
-		self.current_position = Position()
-		self.context = ContextStack()
-		self.labels = LabelStack()
-		self._recursion_depth = 0
-		self.include_path = list()
-		self.silent_warnings = Preprocessor.silent_warnings.copy()
-
-
-	def send_error(self: "Preprocessor", name: str, error_msg: str) -> None:
-		"""Handles errors
-		Inputs:
-		  self - Preprocessor object
-		  name - warning name (lowercase-no-space: ex extra-arguments)
-		  error_msg - string : an error message
-		Effect:
-		  if self.exit_on_error print message and exit
-		  else raise an Exception
-		"""
-		error = PreprocessorError(name, error_msg, self.context)
-		if self.error_mode == ErrorMode.PRINT_AND_EXIT:
-			print(error.pretty_message(self.use_color), file = stderr)
-			exit(self.exit_code)
-		if self.error_mode == ErrorMode.PRINT_AND_RAISE:
-			print(error.pretty_message(self.use_color), file = stderr)
-		raise error
-
-	def send_warning(self: "Preprocessor", name: str, warning_msg: str) -> None:
-		"""Handles warnings
-		Inputs:
-		  self - Preprocessor object
-		  name - warning name (lowercase-no-space: ex extra-arguments)
-		  warning_msg - string : the warning message
-		Effect:
-		  Depends on self.warning_mode:
-		  | HIDE -> do nothing
-		  | PRINT -> print to stderr
-			| PRINT_AND_RAISE -> print to stderr and raise warning
-		  | RAISE -> raise python warning
-		  | AS_ERROR -> passes to self.send_error()
-		"""
-		if name in self.silent_warnings:
-			return
-		warning = PreprocessorWarning(name, warning_msg, self.context)
-		if self.warning_mode == WarningMode.PRINT or self.warning_mode == WarningMode.PRINT_AND_RAISE:
-			print(warning.pretty_message(self.use_color), file = stderr)
-		if self.warning_mode == WarningMode.RAISE or self.warning_mode == WarningMode.PRINT_AND_RAISE:
-			raise warning
-		if self.warning_mode == WarningMode.AS_ERROR:
-			self.send_error("from-warning-"+name, warning_msg)
-
-	def split_args(self: "Preprocessor", args: str) -> List[str]:
-		"""Splits args along space like on the command line
-		preserves strings
-		ex: self.split_args(''' foo -bar\\t "some string" escaped\\ space 'another " string' ''')
-		    returns ["foo", "-bar", "some string", "escaped space" 'another " string']"""
-		arg_list: List[str] = []
-		ii = 0
-		last_blank = 0
-		len_args = len(args)
-		in_string = False
-		string_begin = ""
-		while ii < len_args:
-			if args[ii] == "\\":
-				ii += 1
-				if ii < len_args:
-					# skip escaped character
-					ii += 1
-					continue
-				break
-			if in_string:
-				if args[ii] == string_begin:
-					in_string = False
-					arg_list.append(process_string(args[last_blank + 1 : ii]))
-					last_blank = ii + 1
-			elif args[ii].isspace():
-				if last_blank != ii:
-					arg_list.append(args[last_blank:ii].replace("\\ ", " "))
-				last_blank = ii + 1
-			elif args[ii] in self.string_delimiters:
-				string_begin = args[ii]
-				in_string = True
-			ii += 1
-		# end while
-		if in_string:
-			self.send_error("unmatched-open-quote",
-				"Unterminated string {}... in arguments".format(string_begin)
-			)
-		if last_blank != ii:
-			arg_list.append(args[last_blank:ii].replace("\\ ", " "))
-		return arg_list
-
-	def _find_tokens(self: "Preprocessor", string: str) -> TokenList:
-		"""Find all tokens (begin/end) in string
-		Inputs:
-			string: str - the string to search for tokens
-		Returns:
-			tokens: List[int, TokenMatch] - list of (position, OPEN/CLOSE)
-				sorted by position (CLOSE comes first if equal)
-		"""
-		open_tokens  = re.finditer(re.escape(self.token_begin), string, self.re_flags)
-		close_tokens = re.finditer(re.escape(self.token_end), string, self.re_flags)
-		tokens = [(x.start(), x.end(), TokenMatch.OPEN) for x in open_tokens]
-		tokens += [(x.start(), x.end(), TokenMatch.CLOSE) for x in close_tokens]
-		# sort in order of appearance - if two tokens appear at same place
-		# sort CLOSE first
-		tokens.sort(key=lambda x: x[0] + 0.5 * int(x[2]))
-		return tokens
-
-	@staticmethod
-	def _find_matching_pair(tokens: TokenList) -> int:
-		"""find the first innermost OPEN CLOSE pair in tokens
-		Inputs:
-		  tokens - list of tuples containing 4 elements
-				tokens[i][3] should be a boolean indicating
-				OPEN with True and CLOSE with False
-				Assumed to be at least 2 elements long
-		Returns:
-      the first index i such that tokens[i][3] == True and tokens[i+1][3] == False
-      -1 if no such index exists
-		"""
-		len_tokens = len(tokens)
-		token_index = 0
-		while (
-			tokens[token_index][2] != TokenMatch.OPEN
-			or tokens[token_index + 1][2] != TokenMatch.CLOSE
-		):
-			token_index += 1
-			if token_index + 1 >= len_tokens:
-				return -1
-		return token_index
-
-	def _find_matching_endblock(
-		self: "Preprocessor", block_name: str, string: str
-	) -> Tuple[int, int]:
-		"""Finds the matching endblock
-		i.e. the first enblock token in string that does not
-		match a startblock token
-		Inputs:
-			block_name: str - the name of the block.
-				it is used to determine the endblock and startblock tokens
-			string: str - the string being parsed
-		Returns:
-			tuple(endblock_start_pos: int, endblock_end_pos: int)
-			(-1,-1) if no such endblock exists"""
-		endblock_regex = r"{}\s*{}{}\s*{}".format(
-			re.escape(self.token_begin), re.escape(self.token_endblock),
-			block_name, re.escape(self.token_end)
-		)
-		startblock_regex = r"{}\s*{}(?:{}|{})".format(
-			re.escape(self.token_begin), block_name,
-			re.escape(self.token_end), REGEX_IDENTIFIER_END
-		)
-		pos = 0
-		open_block = 0
-		match_begin = re.search(startblock_regex, string, self.re_flags)
-		match_end = re.search(endblock_regex, string, self.re_flags)
-		while True:
-			if match_end is None:
-				return -1, -1
-			if match_begin is None:
-				open_block -= 1
-				if open_block == -1:
-					return pos + match_end.start(), pos + match_end.end()
-				pos += match_end.end()
-			else:
-				if match_begin.start() < match_end.start():
-					open_block += 1
-					pos += match_begin.end()
-				else:
-					open_block -= 1
-					if open_block == -1:
-						return pos + match_end.start(), pos + match_end.end()
-					pos += match_end.end()
-			match_begin = re.search(startblock_regex, string[pos:], self.re_flags)
-			match_end = re.search(endblock_regex, string[pos:], self.re_flags)
-
-	def replace_string(self: "Preprocessor",
-		start: int, end: int, string: str, replacement: str, tokens: List[Tuple[int, int, Any]],
-		pop_labels: bool = False
-	) -> str:
-		"""replaces string[start:end] with replacement
-		also add offset to token requiring them
-		Inputs:
-			start, end - indexes of the string to replace (relative to start of string)
-			string - the string in which to replace
-			replacement - the replacement string to place between start and end
-			tokens - list of tokens to add dilation
-		Returns:
-			str = string[:start] + replacement + string[end:]
-		Effect:
-			removes all tokens occuring between start and end from tokens
-			corrects start and end of further tokens by the length change
-		"""
-		test_range = range(start, end)
-		i = 0
-		dilat = len(replacement) - (end - start)
-		while i < len(tokens):
-			if tokens[i][0] in test_range or tokens[i][1] in test_range:
-				del tokens[i]
-			else:
-				if tokens[i][0] >= end:
-					tokens[i] = (tokens[i][0] + dilat, tokens[i][1] + dilat) + tokens[i][2:]
-				i += 1
-		self.context.add_dilatation(start+self.current_position.offset, dilat)
-		self.labels.dilate_level(self._recursion_depth, end, dilat)
-		# only remove level if it wasn't explicitly removed
-		if pop_labels and self.labels.height > self._recursion_depth + 1:
-			self.labels.pop_level(start)
-		return string[:start] + replacement + string[end:]
-
-	def safe_call(self: "Preprocessor", function, *args, **kwargs) -> str:
-		"""safely calls function (returning string)
-		catches exceptions and warnings"""
-		if self.safe_calls:
-			string = ""
-			try:
-				string = function(*args, **kwargs)
-			except PreprocessorWarning as warn:
-				raise warn
-			except PreprocessorError as error:
-				raise error
-			except Warning as warn:
-				self.send_warning("internal-warning", "unexpected warning in command or block.\n" + str(warn))
-			except Exception as error:
-				self.send_error("internal-error", "unexpected error in command or block.\n" + str(error))
-			return string
-		return function(*args, **kwargs)
-
-	def token_error(self: "Preprocessor", tokens: TokenList) -> None:
-		"""Raises an error for unmatched token on the first token in list"""
-		self.current_position.relative_begin = tokens[0][0]
-		self.context.update(self.current_position.begin)
-		if tokens[0][2] == TokenMatch.OPEN:
-			self.send_error("unmatched-open-token",
-				'Unmatched "{}" token.\nAdd matching "{}" or use "{}begin{}" to place it.'.format(
-					self.token_begin, self.token_end, self.token_begin, self.token_end
-				)
-			)
-		else:
-			self.send_error("unmatched-close-token",
-				'unmatched "{}" token.\nAdd matching "{}" Use "{}end{}"" to place it.'.format(
-				self.token_end, self.token_begin, self.token_begin, self.token_end)
-			)
-		self.context.pop()
-
-	def parse(self: "Preprocessor", string: str) -> str:
-		"""parses the string, calling the command and blocks it contains
-		calls post_actions when parsing is done
-		Inputs:
-			string - the string to parse
-		Expects:
-			self._context[-1][0] should contain a context describing the string
-			self._context[-1][1] is used to determine offset between string and source
-			  (for error display)
-		Returns:
-			the resulting string"""
-		# Recursion check
-		self._recursion_depth += 1
-		if self._recursion_depth == self.max_recursion_depth:
-			self.send_error("recursion-depth", "recursion depth exceeded.")
-		# add label level if none present
-		if self.labels.height <= self._recursion_depth:
-			self.labels.new_level()
-		# context init
-		self.current_position.offset = self.context.top.position
-
-		tokens: TokenList = self._find_tokens(string)
-
-		while len(tokens) > 1:  # needs two tokens to make a pair
-
-			# find innermost (nested pair)
-			if tokens[0][2] == TokenMatch.CLOSE:
-				self.token_error(tokens)
-			token_index = self._find_matching_pair(tokens)
-			if token_index == -1:
-				self.token_error(tokens)
-
-			self.current_position.relative_begin = tokens[token_index][0]
-			self.current_position.relative_cmd_begin = tokens[token_index][1]
-			self.current_position.relative_cmd_end = tokens[token_index+1][0]
-			self.current_position.relative_end = tokens[token_index+1][1]
-			substring = string[
-				self.current_position.relative_cmd_begin : self.current_position.relative_cmd_end
-			]
-			ident, arg_string, i = get_identifier_name(substring)
-			self.current_position.relative_cmd_argbegin = i
-			end_pos = self.current_position.relative_end
-			self.context.update(self.current_position.begin)
-			new_str = ""
-			position = self.current_position.copy()
-			if ident in self.commands:
-				self.context.update(self.current_position.cmd_begin, "in command {}".format(ident))
-				command = self.commands[ident]
-				new_str = self.safe_call(command, self, arg_string)
-				self.context.pop()
-			elif ident in self.blocks:
-				endblock_b, endblock_e = self._find_matching_endblock(
-					ident, string[self.current_position.relative_end:]
-				)
-				if endblock_b == -1:
-					self.send_error("unmatched-start-block", "no matching endblock for {} block.".format(ident))
-				self.current_position.endblock_begin = endblock_b + self.current_position.end
-				self.current_position.endblock_end = endblock_e + self.current_position.end
-				block_content = string[
-					self.current_position.relative_end : self.current_position.relative_endblock_begin
-				]
-				end_pos = self.current_position.relative_endblock_end
-				block = self.blocks[ident]
-
-				self.context.update(self.current_position.cmd_begin, "in block {}".format(ident))
-
-				new_str = self.safe_call(block, self, arg_string, block_content)
-
-				self.context.pop()
-			else:
-				if ident == "":
-					self.send_warning("invalid-command",
-						"invalid command name: \"{}\".\nIt was ignored and left unchanged in output.".format(
-							substring
-					))
-				else:
-					self.send_warning("undefined-command",
-						"undefined command or block: \"{}\".\nIt was ignored and left unchanged in output.".format(
-							ident
-					))
-				new_str = string[self.current_position.relative_begin : self.current_position.relative_end]
-			self.current_position = position
-			self.context.pop()
-			string = self.replace_string(
-				self.current_position.relative_begin, end_pos, string, new_str, tokens, True
-			)
-		# end while
-		if len(tokens) == 1:
-			self.token_error(tokens)
-		self._recursion_depth -= 1
-		return string
-
-	def run_final_actions(self: "Preprocessor", string: str) -> str:
-		"""Runs all final actions"""
-		self.context.update(self.current_position.from_relative(0), "in final actions")
-		for action in self.final_actions:
-			# run actions
-			string = self.safe_call(action, self, string)
-		self.context.pop()
-		return string
-
-	def process(self: "Preprocessor", string: str, filename: str) -> str:
-		"""parses the string and returns the result
-		Inputs:
-		- string: str -> the string to process
-		- filename: str -> the name of the file (used for error display)
-		Returns the processed string"""
-		self.context.new(FileDescriptor(filename, string), 0)
-		self.labels.new_level()
-		string = self.parse(string)
-		self.labels.pop_level(0)
-		string = self.run_final_actions(string)
-		self.context.pop()
-		return string
-
-	def get_help(self: "Preprocessor", help_msg: str) -> str:
-		"""used to get and display help on the command line
-		help_msg is either:
-			""         -> display program help
-			"commands" -> list all commands and blocks
-			<cmd_name> -> display help relative to a command or block
-		returns the help string
-		"""
-		if help_msg == "":
-			return trim("""
-				{name} version {version}
-				Simple program to preprocess files inspired by the C preprocessor
-
-				Files to process can contain:
-				 - preprocessor commands "{begin} command_name [args] {end}"
-				 - preprocessor blocks "{begin} block_name [args] {end}... {begin} endblock_name {end}"
-				A list of commands and blocks can be obtained with "--help commands"
-
-				Usage: {name} [--flags] [input_file]
-				  default input_file is stdin
-
-				Options:
-				  -o --output <file>   specifies a file to write output to
-				                       default is stdout
-				  -b --begin <string>  change the begin token (default is "{begin}")
-				  -e --end <string>    change the end token (default is "{end}")
-				  -r --recursion_depth <number> set the max recursion depth (default {rec}).
-				                       use -1 for no maximum recursion (dangerous)
-				  -d -D --define <name>[=<value>] defines a simple command
-				                       with name <name> which prints <value> (nothing if no value)
-				                       Can be used multiple times on command line
-				  -i -I --include <path> Adds paths to the INCLUDE_PATH.
-					                     default INCLUDE_PATH is [".", dir(input_file), dir(output_file)]
-				                       Can be used multiple times on command line
-
-				  -w --warnings <hide|error> choose whether to hide warnings
-				                       or have them raise an error. default is display.
-				  -s --silent <warning_name> silence a specific warning (ex: extra-arguments)
-
-				  -v --version         show version and exit
-				  -h --help            show this help and exit
-				  -h --help commands   show a list of commands and blocks and exit
-				  -h --help <cmd_name> show help for a specific command of block
-				""".format(
-					name = PREPROCESSOR_NAME, version = PREPROCESSOR_VERSION,
-					begin = "{%", end = "%}", rec = self.max_recursion_depth))
-		if help_msg == "commands":
-			return "Commands:\n  " + "\n  ".join(sorted(self.commands.keys())) +\
-				"\n\nBlocks:\n  " + "\n  ".join(sorted(self.blocks.keys()))
-		if help_msg in self.commands or help_msg in self.blocks:
-			cmd: Any
-			if help_msg in self.commands:
-				cmd = self.commands[help_msg]
-				cmd_type = "command"
-			else:
-				cmd = self.blocks[help_msg]
-				cmd_type = "block"
-			if hasattr(cmd, "doc"):
-				doc = cmd.doc
-			else:
-				doc = cmd.__doc__
-			doc = "  " + trim(doc).replace("\n", "\n  ")
-			if doc == "":
-				doc = "No help available"
-			return "{}: help on {} {}:\n{}".format(
-				PREPROCESSOR_NAME, cmd_type, help_msg, doc
-			)
-		return "{} help:\nUnknown command or block \"{}\"".format(PREPROCESSOR_NAME, help_msg)
+      Useful attributes that can be configured:
+      - max_recursion_depth: int (default 20) - raises an error past this depth
+      - token_begin and token_end: str (default "{%" and "%}")
+          use these to change the token used around preprocessor calls
+          in the document.
+          They should not be equal or be a simple double quote " or paranthese ( or )
+      - token_endblock: str (default "end")
+          Used to specify what form the endblock command takes
+          (with the regex <token_begin>\\s*<token_endblock><block_name>\\s*<token_end>)
+      - safe_calls: bool (default True)
+          if True, catches exceptions raised by command or blocks
+      - error_mode: ErrorMode (default RAISE)
+          | PRINT_AND_EXIT -> print to stderr and exit
+          | PRINT_AND_RAISE -> print to stderr and raise exception
+          | RAISE -> raise exception"
+      - warning_mode: WarningMode (default RAISE)
+    | HIDE -> do nothing
+    | PRINT -> print to stderr
+    | RAISE -> raise python warning
+    | AS_ERROR -> passes to self.send_error()
+      - use_color: bool (default False)
+          if True, uses ansi color when priting errors
+    """
+
+    # constants
+    max_recursion_depth: int = 20
+    token_begin: str = "{%"
+    token_end: str = "%}"
+    token_endblock: str = "end"
+    re_flags: re.RegexFlag = re.MULTILINE
+    exit_code: int = 4
+    safe_calls: bool = True
+    use_color: bool = False
+    string_delimiters: str = "\"'"
+
+    # warning and error modes
+    error_mode: ErrorMode = ErrorMode.RAISE
+    warning_mode: WarningMode = WarningMode.RAISE
+    silent_warnings: List[str] = []
+
+    # private attributes
+    _recursion_depth: int
+
+    # commands and blocks
+    commands: Dict[str, Command] = dict()
+    blocks: Dict[str, Block] = dict()
+    command_vars: Dict[str, Any] = dict()
+    final_actions: List[Callable[["Preprocessor", str], str]] = []
+
+    # useful variables
+    labels: LabelStack
+    context: ContextStack
+    current_position: Position
+    include_path: List[str]
+
+    def __init__(self) -> None:
+        self.commands = Preprocessor.commands.copy()
+        self.blocks = Preprocessor.blocks.copy()
+        self.final_actions = Preprocessor.final_actions.copy()
+        self.command_vars = Preprocessor.command_vars.copy()
+        self.current_position = Position()
+        self.context = ContextStack()
+        self.labels = LabelStack()
+        self._recursion_depth = 0
+        self.include_path = list()
+        self.silent_warnings = Preprocessor.silent_warnings.copy()
+
+    def send_error(self: "Preprocessor", name: str, error_msg: str) -> None:
+        """Handles errors
+        Inputs:
+          self - Preprocessor object
+          name - warning name (lowercase-no-space: ex extra-arguments)
+          error_msg - string : an error message
+        Effect:
+          if self.exit_on_error print message and exit
+          else raise an Exception
+        """
+        error = PreprocessorError(name, error_msg, self.context)
+        if self.error_mode == ErrorMode.PRINT_AND_EXIT:
+            print(error.pretty_message(self.use_color), file=stderr)
+            exit(self.exit_code)
+        if self.error_mode == ErrorMode.PRINT_AND_RAISE:
+            print(error.pretty_message(self.use_color), file=stderr)
+        raise error
+
+    def send_warning(self: "Preprocessor", name: str, warning_msg: str) -> None:
+        """Handles warnings
+        Inputs:
+          self - Preprocessor object
+          name - warning name (lowercase-no-space: ex extra-arguments)
+          warning_msg - string : the warning message
+        Effect:
+          Depends on self.warning_mode:
+          | HIDE -> do nothing
+          | PRINT -> print to stderr
+                | PRINT_AND_RAISE -> print to stderr and raise warning
+          | RAISE -> raise python warning
+          | AS_ERROR -> passes to self.send_error()
+        """
+        if name in self.silent_warnings:
+            return
+        warning = PreprocessorWarning(name, warning_msg, self.context)
+        if (
+            self.warning_mode == WarningMode.PRINT
+            or self.warning_mode == WarningMode.PRINT_AND_RAISE
+        ):
+            print(warning.pretty_message(self.use_color), file=stderr)
+        if (
+            self.warning_mode == WarningMode.RAISE
+            or self.warning_mode == WarningMode.PRINT_AND_RAISE
+        ):
+            raise warning
+        if self.warning_mode == WarningMode.AS_ERROR:
+            self.send_error("from-warning-" + name, warning_msg)
+
+    def split_args(self: "Preprocessor", args: str) -> List[str]:
+        """Splits args along space like on the command line
+        preserves strings
+        ex: self.split_args(''' foo -bar\\t "some string" escaped\\ space 'another " string' ''')
+            returns ["foo", "-bar", "some string", "escaped space" 'another " string']
+        """
+        arg_list: List[str] = []
+        ii = 0
+        last_blank = 0
+        len_args = len(args)
+        in_string = False
+        string_begin = ""
+        while ii < len_args:
+            if args[ii] == "\\":
+                ii += 1
+                if ii < len_args:
+                    # skip escaped character
+                    ii += 1
+                    continue
+                break
+            if in_string:
+                if args[ii] == string_begin:
+                    in_string = False
+                    arg_list.append(process_string(args[last_blank + 1 : ii]))
+                    last_blank = ii + 1
+            elif args[ii].isspace():
+                if last_blank != ii:
+                    arg_list.append(args[last_blank:ii].replace("\\ ", " "))
+                last_blank = ii + 1
+            elif args[ii] in self.string_delimiters:
+                string_begin = args[ii]
+                in_string = True
+            ii += 1
+        # end while
+        if in_string:
+            self.send_error(
+                "unmatched-open-quote",
+                "Unterminated string {}... in arguments".format(string_begin),
+            )
+        if last_blank != ii:
+            arg_list.append(args[last_blank:ii].replace("\\ ", " "))
+        return arg_list
+
+    def _find_tokens(self: "Preprocessor", string: str) -> TokenList:
+        """Find all tokens (begin/end) in string
+        Inputs:
+                string: str - the string to search for tokens
+        Returns:
+                tokens: List[int, TokenMatch] - list of (position, OPEN/CLOSE)
+                        sorted by position (CLOSE comes first if equal)
+        """
+        open_tokens = re.finditer(re.escape(self.token_begin), string, self.re_flags)
+        close_tokens = re.finditer(re.escape(self.token_end), string, self.re_flags)
+        tokens = [(x.start(), x.end(), TokenMatch.OPEN) for x in open_tokens]
+        tokens += [(x.start(), x.end(), TokenMatch.CLOSE) for x in close_tokens]
+        # sort in order of appearance - if two tokens appear at same place
+        # sort CLOSE first
+        tokens.sort(key=lambda x: x[0] + 0.5 * int(x[2]))
+        return tokens
+
+    @staticmethod
+    def _find_matching_pair(tokens: TokenList) -> int:
+        """find the first innermost OPEN CLOSE pair in tokens
+                  Inputs:
+                    tokens - list of tuples containing 4 elements
+                                  tokens[i][3] should be a boolean indicating
+                                  OPEN with True and CLOSE with False
+                                  Assumed to be at least 2 elements long
+                  Returns:
+        the first index i such that tokens[i][3] == True and tokens[i+1][3] == False
+        -1 if no such index exists
+        """
+        len_tokens = len(tokens)
+        token_index = 0
+        while (
+            tokens[token_index][2] != TokenMatch.OPEN
+            or tokens[token_index + 1][2] != TokenMatch.CLOSE
+        ):
+            token_index += 1
+            if token_index + 1 >= len_tokens:
+                return -1
+        return token_index
+
+    def _find_matching_endblock(
+        self: "Preprocessor", block_name: str, string: str
+    ) -> Tuple[int, int]:
+        """Finds the matching endblock
+        i.e. the first enblock token in string that does not
+        match a startblock token
+        Inputs:
+                block_name: str - the name of the block.
+                        it is used to determine the endblock and startblock tokens
+                string: str - the string being parsed
+        Returns:
+                tuple(endblock_start_pos: int, endblock_end_pos: int)
+                (-1,-1) if no such endblock exists"""
+        endblock_regex = r"{}\s*{}{}\s*{}".format(
+            re.escape(self.token_begin),
+            re.escape(self.token_endblock),
+            block_name,
+            re.escape(self.token_end),
+        )
+        startblock_regex = r"{}\s*{}(?:{}|{})".format(
+            re.escape(self.token_begin),
+            block_name,
+            re.escape(self.token_end),
+            REGEX_IDENTIFIER_END,
+        )
+        pos = 0
+        open_block = 0
+        match_begin = re.search(startblock_regex, string, self.re_flags)
+        match_end = re.search(endblock_regex, string, self.re_flags)
+        while True:
+            if match_end is None:
+                return -1, -1
+            if match_begin is None:
+                open_block -= 1
+                if open_block == -1:
+                    return pos + match_end.start(), pos + match_end.end()
+                pos += match_end.end()
+            else:
+                if match_begin.start() < match_end.start():
+                    open_block += 1
+                    pos += match_begin.end()
+                else:
+                    open_block -= 1
+                    if open_block == -1:
+                        return pos + match_end.start(), pos + match_end.end()
+                    pos += match_end.end()
+            match_begin = re.search(startblock_regex, string[pos:], self.re_flags)
+            match_end = re.search(endblock_regex, string[pos:], self.re_flags)
+
+    def replace_string(
+        self: "Preprocessor",
+        start: int,
+        end: int,
+        string: str,
+        replacement: str,
+        tokens: List[Tuple[int, int, Any]],
+        pop_labels: bool = False,
+    ) -> str:
+        """replaces string[start:end] with replacement
+        also add offset to token requiring them
+        Inputs:
+                start, end - indexes of the string to replace (relative to start of string)
+                string - the string in which to replace
+                replacement - the replacement string to place between start and end
+                tokens - list of tokens to add dilation
+        Returns:
+                str = string[:start] + replacement + string[end:]
+        Effect:
+                removes all tokens occuring between start and end from tokens
+                corrects start and end of further tokens by the length change
+        """
+        test_range = range(start, end)
+        i = 0
+        dilat = len(replacement) - (end - start)
+        while i < len(tokens):
+            if tokens[i][0] in test_range or tokens[i][1] in test_range:
+                del tokens[i]
+            else:
+                if tokens[i][0] >= end:
+                    tokens[i] = (tokens[i][0] + dilat, tokens[i][1] + dilat) + tokens[
+                        i
+                    ][2:]
+                i += 1
+        self.context.add_dilatation(start + self.current_position.offset, dilat)
+        self.labels.dilate_level(self._recursion_depth, end, dilat)
+        # only remove level if it wasn't explicitly removed
+        if pop_labels and self.labels.height > self._recursion_depth + 1:
+            self.labels.pop_level(start)
+        return string[:start] + replacement + string[end:]
+
+    def safe_call(
+        self: "Preprocessor", function: Callable[..., str], *args: Any, **kwargs: Any
+    ) -> str:
+        """safely calls function (returning string)
+        catches exceptions and warnings"""
+        if self.safe_calls:
+            string = ""
+            try:
+                string = function(*args, **kwargs)
+            except PreprocessorWarning as warn:
+                raise warn
+            except PreprocessorError as error:
+                raise error
+            except Warning as warn:
+                self.send_warning(
+                    "internal-warning",
+                    "unexpected warning in command or block.\n" + str(warn),
+                )
+            except Exception as error:
+                self.send_error(
+                    "internal-error",
+                    "unexpected error in command or block.\n" + str(error),
+                )
+            return string
+        return function(*args, **kwargs)
+
+    def token_error(self: "Preprocessor", tokens: TokenList) -> None:
+        """Raises an error for unmatched token on the first token in list"""
+        self.current_position.relative_begin = tokens[0][0]
+        self.context.update(self.current_position.begin)
+        if tokens[0][2] == TokenMatch.OPEN:
+            self.send_error(
+                "unmatched-open-token",
+                'Unmatched "{}" token.\nAdd matching "{}" or use "{}begin{}" to place it.'.format(
+                    self.token_begin, self.token_end, self.token_begin, self.token_end
+                ),
+            )
+        else:
+            self.send_error(
+                "unmatched-close-token",
+                'unmatched "{}" token.\nAdd matching "{}" Use "{}end{}"" to place it.'.format(
+                    self.token_end, self.token_begin, self.token_begin, self.token_end
+                ),
+            )
+        self.context.pop()
+
+    def parse(self: "Preprocessor", string: str) -> str:
+        """parses the string, calling the command and blocks it contains
+        calls post_actions when parsing is done
+        Inputs:
+                string - the string to parse
+        Expects:
+                self._context[-1][0] should contain a context describing the string
+                self._context[-1][1] is used to determine offset between string and source
+                  (for error display)
+        Returns:
+                the resulting string"""
+        # Recursion check
+        self._recursion_depth += 1
+        if self._recursion_depth == self.max_recursion_depth:
+            self.send_error("recursion-depth", "recursion depth exceeded.")
+        # add label level if none present
+        if self.labels.height <= self._recursion_depth:
+            self.labels.new_level()
+        # context init
+        self.current_position.offset = self.context.top.position
+
+        tokens: TokenList = self._find_tokens(string)
+
+        while len(tokens) > 1:  # needs two tokens to make a pair
+            # find innermost (nested pair)
+            if tokens[0][2] == TokenMatch.CLOSE:
+                self.token_error(tokens)
+            token_index = self._find_matching_pair(tokens)
+            if token_index == -1:
+                self.token_error(tokens)
+
+            self.current_position.relative_begin = tokens[token_index][0]
+            self.current_position.relative_cmd_begin = tokens[token_index][1]
+            self.current_position.relative_cmd_end = tokens[token_index + 1][0]
+            self.current_position.relative_end = tokens[token_index + 1][1]
+            substring = string[
+                self.current_position.relative_cmd_begin : self.current_position.relative_cmd_end
+            ]
+            ident, arg_string, i = get_identifier_name(substring)
+            self.current_position.relative_cmd_argbegin = i
+            end_pos = self.current_position.relative_end
+            self.context.update(self.current_position.begin)
+            new_str = ""
+            position = self.current_position.copy()
+            if ident in self.commands:
+                self.context.update(
+                    self.current_position.cmd_begin, "in command {}".format(ident)
+                )
+                command = self.commands[ident]
+                new_str = self.safe_call(command, self, arg_string)
+                self.context.pop()
+            elif ident in self.blocks:
+                endblock_b, endblock_e = self._find_matching_endblock(
+                    ident, string[self.current_position.relative_end :]
+                )
+                if endblock_b == -1:
+                    self.send_error(
+                        "unmatched-start-block",
+                        "no matching endblock for {} block.".format(ident),
+                    )
+                self.current_position.endblock_begin = (
+                    endblock_b + self.current_position.end
+                )
+                self.current_position.endblock_end = (
+                    endblock_e + self.current_position.end
+                )
+                left = self.current_position.relative_end
+                right = self.current_position.relative_endblock_begin
+                block_content = string[left:right]
+                end_pos = self.current_position.relative_endblock_end
+                block = self.blocks[ident]
+
+                self.context.update(
+                    self.current_position.cmd_begin, "in block {}".format(ident)
+                )
+
+                new_str = self.safe_call(block, self, arg_string, block_content)
+
+                self.context.pop()
+            else:
+                if ident == "":
+                    self.send_warning(
+                        "invalid-command",
+                        (
+                            'invalid command name: "{}".\nIt was ignored and left unchanged in'
+                            " output."
+                        ).format(substring),
+                    )
+                else:
+                    self.send_warning(
+                        "undefined-command",
+                        (
+                            'undefined command or block: "{}".\nIt was ignored and left'
+                            " unchanged in output."
+                        ).format(ident),
+                    )
+                new_str = string[
+                    self.current_position.relative_begin : self.current_position.relative_end
+                ]
+            self.current_position = position
+            self.context.pop()
+            string = self.replace_string(
+                self.current_position.relative_begin,
+                end_pos,
+                string,
+                new_str,
+                tokens,
+                True,
+            )
+        # end while
+        if len(tokens) == 1:
+            self.token_error(tokens)
+        self._recursion_depth -= 1
+        return string
+
+    def run_final_actions(self: "Preprocessor", string: str) -> str:
+        """Runs all final actions"""
+        self.context.update(self.current_position.from_relative(0), "in final actions")
+        for action in self.final_actions:
+            # run actions
+            string = self.safe_call(action, self, string)
+        self.context.pop()
+        return string
+
+    def process(self: "Preprocessor", string: str, filename: str) -> str:
+        """parses the string and returns the result
+        Inputs:
+        - string: str -> the string to process
+        - filename: str -> the name of the file (used for error display)
+        Returns the processed string"""
+        self.context.new(FileDescriptor(filename, string), 0)
+        self.labels.new_level()
+        string = self.parse(string)
+        self.labels.pop_level(0)
+        string = self.run_final_actions(string)
+        self.context.pop()
+        return string
+
+    def get_help(self: "Preprocessor", help_msg: str) -> str:
+        """used to get and display help on the command line
+        help_msg is either:
+                ""         -> display program help
+                "commands" -> list all commands and blocks
+                <cmd_name> -> display help relative to a command or block
+        returns the help string
+        """
+        if help_msg == "":
+            return trim(
+                """
+                {name} version {version}
+                Simple program to preprocess files inspired by the C preprocessor
+
+                Files to process can contain:
+                    - commands: "{begin} command_name [args] {end}"
+                    - blocks: "{begin} block_name [args] {end}... {begin} endblock_name {end}"
+                A list of commands and blocks can be obtained with "--help commands"
+
+                Usage: {name} [--flags] [input_file]
+                    default input_file is stdin
+
+                Options:
+                    -o --output <file>   specifies a file to write output to
+                                default is stdout
+                    -b --begin <string>  change the begin token (default is "{begin}")
+                    -e --end <string>    change the end token (default is "{end}")
+                    -r --recursion_depth <number> set the max recursion depth (default {rec}).
+                                use -1 for no maximum recursion (dangerous)
+                    -d -D --define <name>[=<value>] defines a simple command
+                                with name <name> which prints <value> (nothing if no value)
+                                Can be used multiple times on command line
+                    -i -I --include <path> Adds paths to the INCLUDE_PATH.
+                                default INCLUDE_PATH is [".", dir(input_file), dir(output_file)]
+                                Can be used multiple times on command line
+
+                    -w --warnings <hide|error> choose whether to hide warnings
+                                or have them raise an error. default is display.
+                    -s --silent <warning_name> silence a specific warning (ex: extra-arguments)
+
+                    -v --version         show version and exit
+                    -h --help            show this help and exit
+                    -h --help commands   show a list of commands and blocks and exit
+                    -h --help <cmd_name> show help for a specific command of block
+                """.format(
+                    name=PREPROCESSOR_NAME,
+                    version=PREPROCESSOR_VERSION,
+                    begin="{%",
+                    end="%}",
+                    rec=self.max_recursion_depth,
+                )
+            )
+        if help_msg == "commands":
+            return (
+                "Commands:\n  "
+                + "\n  ".join(sorted(self.commands.keys()))
+                + "\n\nBlocks:\n  "
+                + "\n  ".join(sorted(self.blocks.keys()))
+            )
+        if help_msg in self.commands or help_msg in self.blocks:
+            cmd: Any
+            if help_msg in self.commands:
+                cmd = self.commands[help_msg]
+                cmd_type = "command"
+            else:
+                cmd = self.blocks[help_msg]
+                cmd_type = "block"
+            if hasattr(cmd, "doc"):
+                doc = cmd.doc
+            else:
+                doc = cmd.__doc__
+            doc = "  " + trim(doc).replace("\n", "\n  ")
+            if doc == "":
+                doc = "No help available"
+            return "{}: help on {} {}:\n{}".format(
+                PREPROCESSOR_NAME, cmd_type, help_msg, doc
+            )
+        return '{} help:\nUnknown command or block "{}"'.format(
+            PREPROCESSOR_NAME, help_msg
+        )
```

## Comparing `mlpproc-1.0.2.data/data/LICENSE` & `mlpproc-1.0.3.data/data/LICENSE`

 * *Files identical despite different names*

## Comparing `mlpproc-1.0.2.dist-info/LICENSE` & `mlpproc-1.0.3.dist-info/LICENSE`

 * *Files identical despite different names*

## Comparing `mlpproc-1.0.2.dist-info/METADATA` & `mlpproc-1.0.3.dist-info/METADATA`

 * *Files 3% similar despite different names*

```diff
@@ -1,10 +1,10 @@
 Metadata-Version: 2.1
 Name: mlpproc
-Version: 1.0.2
+Version: 1.0.3
 Summary: MLPP: Markup Language Pre-Processor for text files (code/html/tex/...) inspired by the C preprocessor
 Home-page: https://github.com/dlesbre/mlpproc
 Author: Dorian Lesbre
 Author-email: dorian.lesbre@gmail.com
 License: MIT
 Keywords: mlpproc preprocessor preprocess markup language python terminal
 Platform: any
@@ -24,17 +24,18 @@
 Classifier: Topic :: Software Development :: Pre-processors
 Classifier: Topic :: Text Processing :: Markup
 Classifier: Typing :: Typed
 Requires-Python: >=3.6
 Description-Content-Type: text/markdown
 License-File: LICENSE
 Provides-Extra: dev
+Requires-Dist: pytest ; extra == 'dev'
 Requires-Dist: mypy ; extra == 'dev'
 Requires-Dist: pre-commit ; extra == 'dev'
-Requires-Dist: pytest ; extra == 'dev'
+Requires-Dist: isort ; extra == 'dev'
 
 # MLPProc : Markup Language Pre-Preprocessor
 
 [![Maintenance](https://img.shields.io/badge/Maintained%3F-yes-brightgreen.svg)](https://github.com/dlesbre/mlpproc/graphs/commit-activity)
 [![PyPI version](https://img.shields.io/pypi/v/mlpproc.svg)](https://pypi.python.org/pypi/mlpproc/)
 [![PyPI pyversions](https://img.shields.io/pypi/pyversions/mlpproc.svg)](https://pypi.python.org/pypi/mlpproc/)
 [![License](https://img.shields.io/pypi/l/mlpproc.svg)](https://github.com/dlesbre/mlpproc/blob/master/LICENSE)
@@ -58,56 +59,56 @@
   - [Blocks](#blocks)
 - [Defining commands, blocks and final actions](#defining-commands-blocks-and-final-actions)
   - [Useful functions](#useful-functions)
 
 ## Installation
 
 This package has no dependencies. To install simply run
-```
+```console
 pip install mlpproc
 ```
 
 Once installed you can call the preprocessor with
-```
+```console
 mlpp --version
 python -m mlpproc --version
 ```
 
 ## Manual installation
 
 For a manual installation run
 
-```
+```console
 git clone https://github.com/dlesbre/mlpproc.git &&
 cd mlpproc &&
 python3 -m venv venv &&
 source venv/bin/activate &&
 make setup
 ```
 
 For development install, run `make setup-dev` to install extra dependencies and setup pre-commit.
 
 ## Preprocessor syntax
 
 ### Basic syntax
 
-The preprocessor instructions are wrapped between "{%" and "%}". These tokens can be changed if they conflict with the syntax of the file's langage. Instructions are case sensitive.
+The preprocessor instructions are wrapped between "{%" and "%}". These tokens can be changed if they conflict with the syntax of the file's langage. Instructions are case-sensitive.
 
 Preprocessor instructions are split in three categories :
 
-- **commands**: `{% command [args] %}`
+- **Commands**: `{% command [args] %}`
 
 	Commands print text where they are placed. For instance `{% date %}` prints the current date.
 	Some special commands print no text but perform actions. `{% def name my_name %}` prints nothing but defines a new command `{% name %}` which prints `my_name`.
 
-- **blocks**: `{% block_name [args] %} ... some text ... {% endblock_name %}`
+- **Blocks**: `{% block_name [args] %} ... some text ... {% endblock_name %}`
 
 	Blocks work very similarly to commands: they wrap around some text and alter it in some way. For instance the `{% verbatim %}` block prints all text in itself verbatim, without rendering any of the commands.
 
-- **final actions**: some actions can be queued by special commands. They occur once every command and block in the file has been rendered and affect the whole current file. For instance `{% replace foo bar %}` will replace all instances of "foo" with "bar" in the whole rendered file (including occurrences before the command is called). Final actions can be restricted to a smaller part of the document with `{% block -a %}...{% endblock %}` :
+- **Final actions**: some actions can be queued by special commands. They occur once every command and block in the file has been rendered and affect the whole current file. For instance `{% replace foo bar %}` will replace all instances of "foo" with "bar" in the whole rendered file (including occurrences before the command is called). Final actions can be restricted to a smaller part of the document with `{% block -a %}...{% endblock %}` :
 
 		some text... foo here is not replaced
 		{% begin block -a %}
 			foo here is replaced
 			{% replace foo bar %}
 			foo here is replaced
 			{% begin block %}
@@ -127,16 +128,18 @@
 
 ---
 
 ## Command line usage
 
 The preprocessor can be called from the command line with:
 
-	mlpp [--flags] [input_file]
-	python3 -m mlpproc [--flags] [input_file]
+```console
+mlpp [--flags] [input_file]
+python3 -m mlpproc [--flags] [input_file]
+```
 
 The default input file is `stdin`. Command line options are:
 
 - `-o --output <file>` specifies a file to write output to. Default is stdout
 - `-b --begin <string>` change the begin token (default is `"{% "`)
 - `-e --end <string>` change the end token (default is `" %}"`)
 - `-r --recursion_depth <number>` set the max recursion depth (default {rec}). Use -1 for no maximum recursion (dangerous)
@@ -247,14 +250,18 @@
    def foo " some text " -> {% foo %} prints " some text "
    def foo(arg1, arg2) text with arg1 and arg2
       -> {% foo bar "hi there" %} prints "text with bar and hi there"
 
   def overwrites old commands and blocks irreversibly.
   All defs are global, including those coming from sub-blocks and included files.
 
+  The text in a def is effectively rendered twice:
+  - the text is rendered once at definition (due to nesting)
+  - when the new command is called argument substitution takes place first
+    and the text is re-rendered before printing
   defs can use nesting and recursive calls using command like call, begin and end.
 
     {% def name john %}
 
     // name is evaluated before def
     {% def rec1 {% name %} %}
 
@@ -267,26 +274,26 @@
     {% def rec3 {% call call name %} %}
 
     {% def name alice %}
     {% rec1 %} -> prints john
     {% rec2 %} -> prints alice
     {% rec3 %} -> prints {% name %}
 
-  defs can be overloaded on the number of arguments
+  defs can be overloaded on the number of arguments:
 
     {% def sum(a,b) a+b %}
     {% def sum(a)   {% sum a 0 %} %}
     {% sum 5 10 %} -> prints 5+10
     {% sum 5 %}    -> prints 5+0
 ```
 
 #### deflist
 
 ```
-  Defines a new command.
+  Defines a new command for a list of objects.
 
   Usage: deflist list_name space separated list " element with spaces "
 
   Defines list_name such that:
           list_name          prints the lists
           list_name <number> prints the n-th element
                              (number must be a between -length+1 and length+1)
@@ -486,16 +493,17 @@
   Renders a chunk of text and places it at all labels matching
   its label when processing is done.
 
   Usage: atlabel <label>
 
   It differs from the cut block in that:
   - it will also print its content to calls of {% label XXX %} preceding it
-  - it can't be overwriting (at most one atlabel block per label)
-  - the text is rendered in the block (and not in where the text is pared)
+  - it can't be overwritten (at most one atlabel block per label)
+  - the text is rendered just once, at the atlabel block definition
+    (and not in where the text will be placed)
 
   ex:
     "{% def foo bar %}
     first label: {% label my_label %}
     {% atlabel my_label %}foo is {% foo %}{% endatlabel %}
           {% def foo notbar %}
     second label: {% label my_label %}"
@@ -548,15 +556,15 @@
 
 ```
   Used to cut a section of text to paste elsewhere.
   The text is processed when pasted, not when cut
 
   Usage: cut [--pre-render|-p] [<clipboard_name>]
     if --pre-render - renders the block here
-      (will be rerendered at time of pasting, unless using paste -v|--verbatim)
+      (it will be re-rendered at time of pasting, unless using paste -v|--verbatim)
     clipboard is a string identifying the clipboard, default is ""
 
   ex:
     {% cut %}foo is {% foo %}{% endcut %}
     {% def foo bar %}
     first paste: {% paste %}
     {% def foo notbar %}
@@ -664,45 +672,54 @@
 
 ---
 
 ## Defining commands, blocks and final actions
 
 This package is designed to simply add new commands and blocks:
 
-- **commands**: they are function with signature:
+- **commands**: they are classes inherinting from command, they should define `__call__` and doc signature:
 	```Python
-	def command_func(p: Preprocessor, args: str) -> str
+	class MyCommand(Command):
+	    def __call__(self, p: Preprocessor, args: str) -> str:
+ 	        ...
+
+ 	    doc = "documentation for my command"
 	```
 
 	The first argument is the preprocessor object, the second is the args string entered after the command. For example when calling `{% command_name some args %}` args will contain `" some args "` including leading/trailing spaces.
 
 	The return value is the string to be inserted instead of the command call.
 
 	Command are stored in the preprocessor's `command` dict. They can be added with:
 
 	```Python
 	# adds the command to all new Preprocessor objects
-	Preprocessor.commands["command_name"] = command_function
+	Preprocessor.commands["command_name"] = MyCommand()
 	# adds the command to a specific Preprocessor object
-	my_preproc_obj.commands["command_name"] = command_function
+	my_preproc_obj.commands["command_name"] = MyCommand()
 	```
 
-- **blocks**: they are functions with signature:
-	```Python
-	def block_func(p: Preprocessor, args: str, block_contents: str) -> str
-	```
+- **blocks**: they are classes with signature:
+ 	```Python
+ 	class MyBlock(Block):
+
+ 	    def __call__(self, p: Preprocessor, args: str, block_contents: str) -> str:
+ 	        ...
+
+ 	    doc = "my block documentation"
+ 	```
 
 	`args` is the blocks argument, just like in commands, and `block_contents` is everything between `{% block args %}` and `{% endblock %}`.
 
 	They return a string that replaces the whole block `{% block ... %}...{% endblock %}`
 
 	Blocks are stored in the preprocessor's `blocks` dict. They can be added with:
 
 	```Python
-	Preprocessor.blocks["block_name"] = block_func
+	Preprocessor.blocks["block_name"] = MyBlock()
 	```
 
 - **final actions**: they have the same signature as commands:
 	```Python
 	def final_action_function(p: Preprocessor, text: str) -> str
 	```
 
@@ -715,24 +732,14 @@
 	```Python
 	# adds a post action to the whole class
 	Preprocessor.final_actions.append(post_action_function)
 	# adds a post action to a specific object
 	preprocessor_obj.final_actions.append(post_action_function)
 	```
 
-	Adding block actions with commands to run in the current block is pretty simple via the `final_action_command` decorator:
-
-	```Python
-	def my_post_action(p: Preprocessor, args: str) -> str:
-		# not added to Preprocessor.post_actions
-		...
-
-	Preprocessor.commands["run_my_post_action"] = final_action_command(my_post_action_command)
-	```
-
 ### Useful functions
 
 Some useful functions and attribute that are useful when defining commands or blocks
 
 - `Preprocessor.split_args(self, args: str) -> List[str]` - use split a command or block arguments like the command line would.
 	You can then parse them with `argparse`. However, `argparse` exits on parsing errors, so the module provide
 	```Python
@@ -740,9 +747,7 @@
 	```
 	which raises `argparse.ArgumentError` instead of exiting, allowing errors to be caught and passed to the preprocessor error handling system.
 - `Preprocessor.send_error(self, name: str, msg: str)` - sends an error (and exits). Errors should be only fatal problems. Non-fatal problems should be warnings.
 - `Preprocessor.send_warning(self, name: str, msg: str)` - sends a warning.
 - `Preprocessor.current_position: Position` - variable containing all position info.
 - `Preprocessor.parse(self, string: str) -> str` - processed the string commands and blocks and returns the parsed version
 	It can be used for block contents, recursive defines, or any text which has preprocessor syntax.
-
-
```

## Comparing `mlpproc-1.0.2.dist-info/RECORD` & `mlpproc-1.0.3.dist-info/RECORD`

 * *Files 22% similar despite different names*

```diff
@@ -1,20 +1,19 @@
-mlpproc/__init__.py,sha256=E3yT8YV1UhTTXyQwkoXeb8OW9K4RfN1t8KM24S0e5GI,1054
-mlpproc/__main__.py,sha256=bMhmAyNwMF3IGFDb8rvFbpXgl06WEg4sfrnxEf9rBGY,5263
-mlpproc/blocks.py,sha256=HH_zkCL6EdbDinSke4h9Cn_JPIjXA52KAeBDH0bp9Jw,18205
-mlpproc/commands.py,sha256=XeNAjxH4eVP4LQsoqk_TLZ4kwx4aN_YzuGPbsJODPTo,21177
-mlpproc/conditions.py,sha256=DhaETqXC7S2xF0q40C79-SW0Vl9BKcyLxqYDfwo2IBI,4425
-mlpproc/context.py,sha256=Tlri2mHRbO0D8ESelThrxbMyo2EYihFq54lO0Ha3ETE,5867
-mlpproc/defaults.py,sha256=UTN2COHm-oADfQVdqUBtGlAXQfBv34EZETzIPOfSIig,2051
-mlpproc/defs.py,sha256=rplXqT1wST7IlWvKvqcKd8L7T11q_UCYl_DnEo-EHBQ,6755
-mlpproc/errors.py,sha256=WDBlj3NqQWkh0NvhNf3DYinlveodJi0CWRzpVDlsupA,5124
-mlpproc/final_actions.py,sha256=ahBmiJ-3L_8knvpob0ZyOt8v3iKNMRQfk7er22_xcmY,11246
-mlpproc/labels.py,sha256=12Bdtw-V74qdLbpnlM_1WBq6hD2aun7Ab1mIl0q7JE4,3744
-mlpproc/preprocessor.py,sha256=Hz7BLmmv8TNj5oQmh7vj9baXO4HmsqboeagFEZwCdak,18945
-mlpproc/types.py,sha256=bDuoCjYySi-wmlmEQtGxl5lYbI6QLH0_ko6ZlU2ptqI,1614
-mlpproc-1.0.2.data/data/LICENSE,sha256=_q7koQrvd-n3CZ-V1LbFbwRGLMmH56rzL1KVFJUTZdQ,1070
-mlpproc-1.0.2.data/scripts/mlpp,sha256=inDPtXdvkkliywq4h38KEPxQe-gwnG4kCHhMfRQ0Lqo,78
-mlpproc-1.0.2.dist-info/LICENSE,sha256=_q7koQrvd-n3CZ-V1LbFbwRGLMmH56rzL1KVFJUTZdQ,1070
-mlpproc-1.0.2.dist-info/METADATA,sha256=LsDAYs5u26fE0LwEEdfoKI7N0EvhxwLXIi9D6U8klHU,23508
-mlpproc-1.0.2.dist-info/WHEEL,sha256=G16H4A3IeoQmnOrYV4ueZGKSjhipXx8zc8nu9FGlvMA,92
-mlpproc-1.0.2.dist-info/top_level.txt,sha256=1VM9JFi69RBZXBIIFRvMoRHZQgC65d7jLStTFDIKnAY,8
-mlpproc-1.0.2.dist-info/RECORD,,
+mlpproc/__init__.py,sha256=QjefYTkL4IBC4x_6xWkXXH6KxvvALsVxsDV4-aysRD4,1244
+mlpproc/__main__.py,sha256=V_2iDqhqREXZlVuyOk-51iSHXzFxRZJv72WDunb4274,6116
+mlpproc/blocks.py,sha256=8Joo5f3gtxFoDXTljc42QyAMmLlgu9Ly3GTBoq66jCU,22874
+mlpproc/commands.py,sha256=3gPzOfpg7a7HyeUGEgIcdPuxXJZzhEAdnYBn8ec57lQ,29959
+mlpproc/conditions.py,sha256=29MXyNmgLTLgjepvf1QGI74OIkBNHxUQNNMToJvJZhs,5576
+mlpproc/context.py,sha256=zrp99ybJcFxZm05LHsaBOIrfSuevrPlgOL5nOvKKx74,6740
+mlpproc/defaults.py,sha256=Wki-MyrmU9t_vSk9imbXSuVFb6eJL6X5hF7RSeWf8o4,2807
+mlpproc/defs.py,sha256=iKWXS9OG6cxko1-aPSqBz9RCKrvGKkpBists0I8FGEI,7372
+mlpproc/errors.py,sha256=veyQj-NUHgnjhBPvn5eMLp67g-RMh-uSBHA61Au7kr8,5849
+mlpproc/final_actions.py,sha256=0OpwJ3aGBUgovzOHzYjFHk6vJ1oM93Go6jNyFZdhi1E,13427
+mlpproc/labels.py,sha256=sghcewKtK8ZfiLCNS_i6Mly3VQJiyORtzZYVt15kJRM,4369
+mlpproc/preprocessor.py,sha256=5Zo7B8NsHxTc2huTT_pFqySLLl2LTM3WyA3QJeAMPkk,24610
+mlpproc-1.0.3.data/data/LICENSE,sha256=_q7koQrvd-n3CZ-V1LbFbwRGLMmH56rzL1KVFJUTZdQ,1070
+mlpproc-1.0.3.data/scripts/mlpp,sha256=inDPtXdvkkliywq4h38KEPxQe-gwnG4kCHhMfRQ0Lqo,78
+mlpproc-1.0.3.dist-info/LICENSE,sha256=_q7koQrvd-n3CZ-V1LbFbwRGLMmH56rzL1KVFJUTZdQ,1070
+mlpproc-1.0.3.dist-info/METADATA,sha256=MPw1cZVhtf2CbZQnNTf0_UfoMJk5N5wr-ls0uvOjwXQ,23767
+mlpproc-1.0.3.dist-info/WHEEL,sha256=GJ7t_kWBFywbagK5eo9IoUwLW6oyOeTKmQ-9iHFVNxQ,92
+mlpproc-1.0.3.dist-info/top_level.txt,sha256=1VM9JFi69RBZXBIIFRvMoRHZQgC65d7jLStTFDIKnAY,8
+mlpproc-1.0.3.dist-info/RECORD,,
```

